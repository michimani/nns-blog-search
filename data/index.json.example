[
  {
    "contents": "Lambda 関数に対して URL を発行して外部から HTTP で実行できるようにする Function URLs ですが、そのままだと自動で発行されるドメインに対してリクエストを送ることになります。今回は、任意のドメインで Function URLs を利用する構成を AWS CDK を使って構築してみた話です。\n構成については構成図を見ればわかるので、記事の内容としては AWS CDK での実装にコメントを足していくような感じになります。\nまえがき 構成図 AWS CDK で作成するリソース Route 53 Certificate Manager CloudFront Lambda まとめ まえがき タイトルにもある通り、 Lambda Function URLs をカスタムドメインで使う構成を AWS CDK v2 (Go) で構築してみます。\nAWS CDK: 2.64.0 Go: 1.20 Function URLs を使って Lambda 関数に対して URL を発行すると、ランダムな英数字を含んだ下記のような URL が発行されます。\nhttps://{ランダムな英数字}.lambda-url.{リージョン}.on.aws/ 今回は、 前段に CloudFront を配置することで任意のドメインで Function URLs による Lambda 関数の実行ができるようにします。\nソースコードは下記に置いてあるので、お手元でも試していただけます。\naws-cdk-go-examples/lambda-function-urls-with-custom-domain at main · michimani/aws-cdk-go-examples 構成図 構成図としては下記のようになります。\nC4Component Container_Boundary(r53, \"Route 53\") { Component(h, \"HostedZone\", \"hosted zone\",\"imported by HostedZoneID\") Component(r, \"RecordSet\", \"custom domain record\",\"e.g) api.example.com -\u003e xxxxxx.cloudfront.net\") Rel(r, h, \"\") } Container_Boundary(acm, \"Certificate Manager\") { Component(c, \"Certificate\", \"SSL Certificate\", \"imported by ARN\") } Container_Boundary(cf,\"CloudFront\") { Component(oap, \"Origin Access Policy\", \"\", \"\") Component(dist, \"Distribution\", \"\", \"\") Component(cp, \"Cache Policy\", \"\", \"\") Rel_L(dist, cp, \"\", \"\") Rel_L(dist, oap,\"\", \"\") } Container_Boundary(lambda, \"Lambda\") { Component(url1, \"Function URL\", \"\", \"for default behavior\") Component(url2, \"Function URL\", \"\", \"for hello behavior\") Component(url3, \"Function URL\", \"\", \"for bye behavior\") Component(fn1, \"Function\", \"\", \"simple-response-default\") Component(fn2, \"Function\", \"\", \"simple-response-hello\") Component(fn3, \"Function\", \"\", \"simple-response-bye\") Rel(url1, fn1, \"\",\"\") Rel(url2, fn2, \"\",\"\") Rel(url3, fn3, \"\",\"\") } Rel_D(dist, c, \"\", \"\") Rel_D(r, dist, \"\", \"\") Rel_D(dist, url1, \"\",\"default\") Rel_D(dist, url2, \"\",\"/hello pattern\") Rel_D(dist, url3, \"\",\"/bye pattern\") UpdateElementStyle(h, $bgColor=\"grey\") UpdateElementStyle(c, $bgColor=\"grey\") UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\") Lambda 関数を 3 つ用意してそれぞれに Function URL を発行、CloudFront の Behavior でそれぞれの Function URL にリクエストが分配されるようにします。\n背景が水色になっているリソースを AWS CDK で構築します。灰色になっている Route53:HostedZone と CertificateManager:Certificate は、あらかじめ作成されているものを HostedZoneID と ZoneName および ARN でそれぞれインポートして利用します。\nAWS CDK で作成するリソース 今回は Route 53, Certificate Manager, CloudFront, Lambda に関連するリソースを作成します。\nRoute 53 Route 53 関連では、 任意のドメインから CloudFront のドメインに対する A レコードとなる RecordSet を作成します。その際、 RecordSet を紐付かせる HostedZone が必要になりますが、これについては既に存在している HostedZone を HostedZoneID と ZoneName をもとにしてインポートします。\nhostedZone := awsroute53.HostedZone_FromHostedZoneAttributes(scope, jsii.String(\u0026#34;MyHostedZone\u0026#34;), \u0026amp;awsroute53.HostedZoneAttributes{ HostedZoneId: \u0026amp;hostedZoneID, ZoneName: \u0026amp;zoneName, }) インポートした HostedZone を使って、 CloudFront に対する A レコードを作成します。 CloudFront に対する A レコードのターゲットについては awsroute53targets.NewCloudFrontTarget() を使って作成できます。\n// scope constructs.Construct // dist awscloudfront.Distribution // subDomain string // このドメインで Lambda 関数を実行できるようにする aliasTarget := awsroute53.RecordTarget_FromAlias( awsroute53targets.NewCloudFrontTarget(dist), ) props := \u0026amp;awsroute53.RecordSetProps{ RecordName: jsii.String(subDomain), RecordType: awsroute53.RecordType_A, Zone: hostedZone, Target: aliasTarget, } awsroute53.NewRecordSet(scope, jsii.String(\u0026#34;RecordSet\u0026#34;), props) aws-cdk-go-examples/route53.go at main · michimani/aws-cdk-go-examples Certificate Manager Certificate Manager については、既に存在している Certificate を ARN でインポートして利用します。\nceritificate := awscertificatemanager.Certificate_FromCertificateArn( stack, jsii.String(\u0026#34;ImportedCertificate\u0026#34;), jsii.String(\u0026#34;arn:aws:acm:us-east-1:000000000000:certificate/hoge\u0026#34;)) CloudFront CloudFront 関連では、 CachePolicy, OriginRequestPolicy, Distribution のリソースを作成します。 それぞれ特に難しいところはない1 のですが、 Distribution のカスタムオリジンとして Function URL の ドメイン をしていするところで小細工が必要でした。 Distribution のカスタムオリジンに Function URL を利用する場合、設定するのは URL ではなく ドメイン部分のみ となります。\nCloudFront ディストリビューションのオリジンとして Lambda 関数 URL を使用するには、オリジンドメインとして Lambda 関数 URL の完全なドメイン名を指定します。\nCloudFront ディストリビューションでのさまざまなオリジンの使用 - Amazon CloudFront AWS CDK において Function URL については awslambda.FunctionUrl.Url() で参照できるのですが、 Distribution と同じ scope 内で FunctionURL を作成している場合には DistributionProps 内で利用する時点ではまだ値が確定していません。なので、 strings.Replace などを使って https:// を取り除くことができません。そのため、 CloudFormation の Fn を利用して URL からドメイン部分のみを抜き出す必要があります。具体的には、下記のような関数を用意して加工しました。\nvar slash string = \u0026#34;/\u0026#34; func functionURLDomain(furl awslambda.FunctionUrl) *string { // function url format: https://hoge.lambda-url.ap-northeast-1.on.aws/ // split: [\u0026#34;https:\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hoge.lambda-url.ap-northeast-1.on.aws\u0026#34;, \u0026#34;\u0026#34;] splitURL := awscdk.Fn_Split(\u0026amp;slash, furl.Url(), jsii.Number(4)) return (*splitURL)[2] } AWS CDK には CloudFormation の Fn を再現するための関数が要されており、今回は文字列を分割する Fn_Split を使っています。\nこのようにすることで、 cdk synth を実行した際の CFn テンプレートは下記のような形で生成されます。\nAWSCDKGoExampleFunctionURLFunctionCFDistribution6BF356B9: Type: AWS::CloudFront::Distribution Properties: DistributionConfig: Origins: - ConnectionAttempts: 1 ConnectionTimeout: 5 CustomOriginConfig: OriginProtocolPolicy: https-only OriginSSLProtocols: - TLSv1.2 DomainName: Fn::Select: - 2 - Fn::Split: - / - Fn::GetAtt: - AwsCdkGoExampleSimpleResponseDefaultUrlB01107C8 - FunctionUrl Id: LambdaFunctionUrlsWithCustomDomainStackAWSCDKGoExampleFunctionURLFunctionCFDistributionOrigin181CAA1CC OriginCustomHeaders: - HeaderName: x-aws-cdk-go-example-from HeaderValue: aws-cdk-go-example-cf また、任意の Origin Custom Header を設定しておくことで、後述する Lambda 関数の実装にて直接 Function URL の URL を叩かれたときの対策とすることができます。今回は x-aws-cdk-go-example-from というヘッダに aws-cdk-go-example-cf という値を設定するようにしています。\ncustomHeaderForFunction := map[string]*string{ \u0026#34;x-aws-cdk-go-example-from\u0026#34;: jsii.String(\u0026#34;aws-cdk-go-example-cf\u0026#34;), } props := \u0026amp;awscloudfront.DistributionProps{ Enabled: jsii.Bool(true), DefaultBehavior: \u0026amp;awscloudfront.BehaviorOptions{ CachePolicy: cachePolicy, OriginRequestPolicy: originRequestPolicy, Origin: awscloudfrontorigins.NewHttpOrigin(defaultFnURLDomain, \u0026amp;awscloudfrontorigins.HttpOriginProps{ ConnectionAttempts: jsii.Number(1), ConnectionTimeout: awscdk.Duration_Seconds(jsii.Number(5)), CustomHeaders: \u0026amp;customHeaderForFunction, ProtocolPolicy: awscloudfront.OriginProtocolPolicy_HTTPS_ONLY, OriginSslProtocols: \u0026amp;[]awscloudfront.OriginSslPolicy{ awscloudfront.OriginSslPolicy(\u0026#34;TLS_V1_2\u0026#34;), }, }), ViewerProtocolPolicy: awscloudfront.ViewerProtocolPolicy_HTTPS_ONLY, }, HttpVersion: awscloudfront.HttpVersion_HTTP2, PriceClass: awscloudfront.PriceClass_PRICE_CLASS_200, EnableLogging: jsii.Bool(false), } aws-cdk-go-examples/cloudfront.go at main · michimani/aws-cdk-go-examples Lambda Lambda 関連では Function と Function URL のリソースを作成しますが、それぞれ特筆するべき点はないのでリソースの定義については割愛します。一方で、 Lambda 関数の実装については工夫すべき点がありました。 CloudFront のところでも書きましたが、今回は Lambda 関数をFunction URL ではなく任意のドメインで実行できるようにするため、 Function URL を直接叩かれたときにはエラーにしたいです。これを実現するためには、 Lambda 関数内で CloudFront からのリクエスト時に付与されるカスタムヘッダを検査します。\nfunc handleRequest(ctx context.Context, httpRequest events.APIGatewayProxyRequest) (response, error) { lctx, ok := lambdacontext.FromContext(ctx) if !ok { return jsonResponse(http.StatusInternalServerError, errorBody{Error: \u0026#34;failed to parse lambda context\u0026#34;}, nil) } if !isAvailableAccess(httpRequest) { return jsonResponse(http.StatusForbidden, errorBody{Error: \u0026#34;forbidden\u0026#34;}, nil) } body := okBody{ RequestID: lctx.AwsRequestID, Message: message, Time: time.Now().Format(time.RFC3339Nano), } customHeader := map[string]string{ \u0026#34;x-aws-cdk-example\u0026#34;: \u0026#34;lambda-function-urls-with-custom-domain\u0026#34;, } return jsonResponse(http.StatusOK, body, customHeader) } func isAvailableAccess(req events.APIGatewayProxyRequest) bool { // invoke from specified CloudFront if h, ok := req.Headers[customHeaderKeyFromCloudFront]; !ok { fmt.Printf(\u0026#34;custom header %s does not exists. req:%v\u0026#34;, customHeaderKeyFromCloudFront, req) return false } else if h != customHeaderValueFromCloudFront { fmt.Printf(\u0026#34;custom header value is invalid. req:%v\u0026#34;, req) return false } return true } ハンドラ関数で events.APIGatewayProxyRequest を受け取るようにしておくことで、リクエストヘッダを検査することができます。\n上記の実装であれば、 Function URL を直接叩かれたとき (= 特定のリクエストヘッダが含まれないとき) は 403 のレスポンスが返ることになります。\naws-cdk-go-examples/main.go at main · michimani/aws-cdk-go-examples まとめ Lambda Function URL を任意のドメインで実行できるようにする構成を AWS CDK v2 (Golang) で構成してみた話でした。\nFunction URL が発表されたときは 「カスタムドメイン対応してないのかー」と思っていましたが、前段に CloudFront を置けば実現可能であるということがわかりました。\n前段に CloudFront を置くということは、キャッシュの恩恵を受けられるということになります。また、 WAF を利用することで DDoS 攻撃や悪意のある bot 等からのアクセスについても対策することができます。\n今回のように新たに CloudFront を用意するところからとなるとちょっと大変ですが、既に CloudFront を利用したアプリケーションがある状態であれば Behavior の追加だけで実現できることになるので、サーバサイドの実装を Lambda で作って API として使うというのがサクッとできてしまいそうです。\nDistributionProps の構造体がデカすぎる問題はありますが、これは CloudFront 扱う上での宿命なので諦めます\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
    "permalink": "https://michimani.net/post/aws-lambda-function-urls-with-custom-domain/",
    "title": "Lambda Function URLs でカスタムドメインを使う構成を AWS CDK v2 (Go) で構築する"
  },
  {
    "contents": "何も書かないのはあれなので、雑に 2022 年の振り返りをしておきます。\n去年の振り返りの最後に書いていたこと 来年こそは SAP 合格します。それではまた来年👋\n具体的な目標はこれだけでした。\nAWS 認定まわり 2019 年の 7 月に SAA、 2019 年の 12 月に SOA と DVA を取得していたので、それらの有効期限が 2022 に切れることになっていました。\n認定を継続するためにはそれぞれ再取得するか、上位資格となる SAP と DOP を取得する必要がありました。\n結論、 2022 年 6 月に SAP、 11 月に DOP を無事に取得できたので下位資格となる SAA/SOA/DVA も延命することができました。なので、去年の終わりに掲げた目標は達成です。\nこんにちは。私がギリギリを生きるソリューションアーキテクトのプロフェッショナルです。\n今月末で失効する予定だった SAA も延命できたのでヨシ。 pic.twitter.com/DFNyRQpMNm\n\u0026mdash; michimani Lv.870 (@michimani210) June 13, 2022 こんにちは。私がギリギリを生きる DevOps Engineer のプロフェッショナルです。\n来月失効する予定だった DVA と SOA も延命できたのでヨシ。 pic.twitter.com/fOb7pWKFes\n\u0026mdash; michimani Lv.870 (@michimani210) November 29, 2022 それぞれスコアはギリギリでしたが、合格できたのでヨシ。\nこれで AWS 認定は 5 つになったわけです。\n全部取ろうとかは思ってないですが、来年は Specialty の認定一つくらいは挑戦してみたいです。\n開発まわり (ざっくり) 去年の振り返り記事で、ふんわりと 「Go も勉強します」みたいなことを書いてました。\n去年作った Twitter API v2 用ライブラリもスター数が 66 まで増えて、 「盆栽を育てるように細々とメンテしていこうと思います。」 というのは達成かなと。利用者から issue 報告や PR が飛んできたりもして、あー使われてんなー感を感じることができました。\n今年は、 Go 以外だと Rust を触り始めてみたり、 AWS リソースを定義するのに Terraform と仲良くなったり、というのが新しい領域だったと思います。この辺については、今年新たに GitHub に作ったリポジトリを見ていって振り返ろうと思います。\n今年 GitHub に作ったリポジトリ 対象リポジトリの取得には、 gh コマンドで取得しました。\ngh repo list \\ --json name,createdAt,url \\ -q \u0026#39;.[] | select(.createdAt | test(\u0026#34;2022-\u0026#34;))\u0026#39; \\ --visibility public \\ --source \\ | jq --slurp \u0026#39;. | sort_by(.createdAt)\u0026#39; programming-Rust-2nd michimani/programming-Rust-2nd これは Rust の勉強を始めるにあたって O\u0026rsquo;Reilly の 「 プログラミング言語 Rust 第2版 」 を読みながら基本構文の使い方とかを実際にコードで書いていたやつです。\nとりあえず一周して、その後は Project Euler の問題を Rust でやったりしてました。が、まだまだ Rust なにもわからない。\nmichimani/Project-Euler-Solutions: My solutions for Project Euler. (Python, Go, Rust) go-esa michimani/go-esa: Unofficial esa SDK for the Go programming language. Twitter API v2 用ライブラリを作った勢いとその反省を活かそうとして作った、Go 製の esa API 用ライブラリです。\nesa は無料期間が 3ヶ月あるので、その間に作りきりました。無料期間終了後は、個人では使っていません。\ntext-detector michimani/text-detector: This is a library for the Go language to detect text from images. It uses Amazon Rekognition or Google Cloud Vision for text detection. 画像に含まれているテキストを抽出するためのパッケージです。抽出処理には Amazon Rekognition もしくは Google Cloud Vision のどちらかを選べるようになっています。\nREADME が TBD になっていることからも、突発的に作って放置していることがわかります。\nelasticsearch-get-started, get-started-opensearch michimani/elasticsearch-get-started michimani/get-started-opensearch: Hello OpenSearch. Elasticsearch と OpenSearch に入門しようと思って触ってみたやつです。\nOpenSearch については完全に理解した気でいましたがもう完全に忘れてしまったので、やはり継続は大事。\namazon-aws michimani/amazon-aws: The quiz \u0026amp;ldquo;Amazon\u0026amp;rdquo; or \u0026amp;ldquo;AWS\u0026amp;rdquo; or neither? なんとなく React.js に入門するかーと思って作った簡単なクイズアプリです。\nこちらから遊べます。\nQuiz Amazon or AWS aws-cdk-go-examples michimani/aws-cdk-go-examples: This is a repository of example implementations of using AWS CDK with Go language. AWS CDK v2 の Go 言語サポートが GA されたので、実装例を集めてみるか、と思って作ったものです。\nGA されたもののまだまだ情報が少ないので、自分が困ったときの参考になれば十分で、もし他の人の参考になればとても嬉しいです。\nget-started-cdk-terraform michimani/get-started-cdk-terraform CDK for Terraform 入門用に作ったやつです。\n触ってみた結果、管理するリソースが AWS リソースに限られるのであれば AWS CDK のほうが良いな、と思いました。\njsc michimani/jsc: Joins multiple slack channels to display posts in chronological order. Slack で複数チャンネルの TL をマージして見たいな、と思って作ったツールです。\nsqs-lambda-example michimani/sqs-lambda-example: Example of AWS Lambda functions that invoked by message from Amazon SQS. SQS をトリガーとする Lambda 関数について、あまりわかっていなかったで実際に簡単な構成を作ってみたやつです。リソースは Terraform で定義、 Event Source Mapping の Filter Pattern を使ってメッセージごとに異なる Lambda 関数を実行するような構成になっています。\ncontainer-lambda-cicd michimani/container-lambda-cicd: コンテナイメージを利用する Lambda 関数の CI/CD のサンプル。 コンテナイメージを使用する Lambda 関数について、 GitHub Actions を使った CI/CD を整備してみたサンプルです。\nlambda-parameters-extension michimani/lambda-parameters-extension: Sample code of using Parameter and Secret Lambda Extension. Parameter Store および Secret Manager へのリクエスト/レスポンスをキャッシュする Lambda Extension が AWS 公式からリリースされたので、それを試すために作ったやつです。\ngenerative-art michimani/generative-art: 『数学から創るジェネラティブアート - Processing で学ぶ かたちのデザイン』で紹介されているコードを Rust で書いたもの。 リポジトリの description にも書いてますが 「 数学から創るジェネラティブアート - Processing で学ぶ かたちのデザイン 」という本を興味本位で買ったので、底に書かれている実装を Rust でやってみようと思って作ったものです。とりあえずひとつは実装してみましたが、それ以降は進捗がありません。\naws-lambda-api-go michimani/aws-lambda-api-go: This is a client library for Go language to use AWS Lambda\u0026amp;rsquo;s Runtime API, Extension API, Telemetry API, and Logs API. Lambda の Runtime API, Extension API, Telemetry API 用 Go 製ライブラリです。Go で Lambda Extension を作るときに便利になる想定のライブラリです。\nhttp-client-mock michimani/http-client-mock: This is a package to generate a mock of http.Client in Go language. You can easily generate a http. Go で API 用のライブラリを書いていると http.Client をモック化したテストをたくさん書く機会があり、その部分をいい感じに書きやすくするためのパッケージを作りました。\nlambda-api-example michimani/lambda-api-example michimani/aws-lambda-api-go を使った実装例です。大した内容ではないので、作った理由がわかりません。\ninvocation-history-extension michimani/invocation-history-extension: This is a Extension for AWS Lambda Function that records history of invocation at the same runtime environment. Lamdba の Telemetry API を使う Lambda Extension です。\n詳しくはアドベントカレンダーの記事で書いています。\nTelemetry API を使う Lambda Extension を作ってみた - michimani.net その他 数学系の本をいくつか読んだ Google Analytics 4 に移行した オンライン勉強会はあまり参加できなかった (継続) 登壇はした 体重は減らせなかった (継続) 結婚した まとめ 雑に振り返り、と言いつつ GitHub のリポジトリをベースに振り返っただけになってしまいました。\n去年よりは学びはあった気はしつつも、結果 (収入) には結びついていないので、 2023 年は結果 (収入) にも拘っていけたらいいなと思います。\n具体的な目標も書いておかないと振り返るときに不便なのでいくつか。\nAWS 認定の Specialty 系の試験を受ける 数研準一級を受ける 2023 年もがんばりましょう 👋\n",
    "permalink": "https://michimani.net/post/other-retrospect-in-2022/",
    "title": "2022 年を雑に振り返る"
  },
  {
    "contents": "AWS Lambda の Runtime API について調べていたら Extension API、 Telemetry API というものの存在を知り、 ひとつ前の記事 ではそれを使って簡単な Lambda Extension を自作してみました。今回は、 Telemetry API を使う Lambda Extension を作ってみて、 Telemetry API でどのような情報が取得できるのかを確認してみます。\nはじめに Telemetry API とは Telemetry API を使う Lambda Extension の概要 Telemetry API の詳細 1. Subscribe API - PUT /telemetry について 2. Subscriber に対して送信されるイベントについて Telemetry API を使う Extension を作ってみる Telemetry API の Subscriber を起動 Subscribe API をコールして Subscriber を登録 イベントのハンドリング Lambda 関数で使ってみる 準備 Extension と それを使う関数を作成 実行してログを確認 まとめ はじめに この記事は 弁護士ドットコム Advent Calendar 2022 (と AWS LambdaとServerless Advent Calendar 2022 (その2) ) の 12 日目の記事です。\n昨日は @talog による 「textlint のルールを作って仕組みを理解した💪 」 でした。このブログにも linter を導入したい\u0026hellip;\n今回の記事ではタイトルの通り Telemetry API を使った Lambda Extension について書きますが、下記の記事で Lambda Extension そのものについて書いているので合わせて読んでいただくとよいかもしれません。\nAWS Lambda の Extension API を使いたいがために Go で Lambda Extension を自作してみた - michimani.net Telemetry API とは 2022年 11月にリリースされた機能で、 Lambda の実行環境、拡張機能、関数で起こっていることをイベントとして受け取ることができるような API のことです。\nAWS Lambda において、新しい AWS Lambda Telemetry API がリリースされました。これにより、関数の実行に関する強化されたモニタリングデータおよびオブザーバビリティデータを、Lambda 拡張機能で収集できるようになりました。 Telemetry API は、ログ、プラットフォームのトレース、関数呼び出しレベルのメトリクスを Lambda から直接受け取るための、拡張機能用のシンプルなインターフェイスを提供します。\n引用元: AWS Lambda が Telemetry API を導入したことで Lambda 拡張機能のモニタリングとオブザーバビリティがさらに向上 Telemetry API のリリース以前には Logs API というものが提供されており、この API では関数でログが出力されたイベントを受け取ることができていました。 Telemetry API は Logs API の上位互換のような存在で、今後は Logs API の代わりとして Telemetry API を使用することが推奨されています。\nThe Lambda Telemetry API supersedes the Lambda Logs API. While the Logs API remains fully functional, we recommend using only the Telemetry API going forward.\n引用元: Lambda Telemetry API - AWS Lambda Telemetry API を使う Lambda Extension の概要 Lambda Extension で Telemetry API を使う場合、 Extension の実装としては下記のようになります。\nHTTP または TCP でリクエストを受け取るサーバを所定のアドレス (ポートは任意) で起動する 1 で起動したサーバのアドレスを Telemetry API の Subscribe API (PUT /telemetry) を使って登録する 何かしらのイベントが発生した際に Telemetry API から 1 のサーバに対してリクエストが送信されるので、ハンドリングを行う シーケンス図で描くと下記のようなイメージです。\nsequenceDiagram participant ls as Lambda Service participant eapi as Extension API participant tapi as Telemetry API participant main as Extension (main) participant sub as Extension (subscriber) alt Init ls -\u003e\u003e main: start (init extensions in /ops/extensions) main -\u003e\u003e eapi: POST /extension/register eapi -\u003e\u003e main: OK + ExtensionIdentifier main -\u003e\u003e sub: Start HTTP (or TCP) server sub -\u003e\u003e main: OK + listenAddress main -\u003e\u003e tapi: PUT /telemetry with ExtensionIdentifier + listenAddress tapi -\u003e\u003e main: OK end loop Repeat main -\u003e\u003e eapi: GET /extension/event/next eapi -\u003e\u003e main: INVOKE/SHUTDOWN event tapi -\u003e\u003e sub: platform/extension/function event sub -\u003e\u003e sub: handle event end 上記の通り、Extension からコールする Telemetry API としては PUT /telemetry の Subscribe API のみです。\nTelemetry API の詳細 ここでは Telemetry API の詳細として、下記の 2 点について整理します。\nSubscribe API - PUT /telemetry について Subscriber に対して送信されるイベントについて 1. Subscribe API - PUT /telemetry について Subscribe API は、 Extension からコールする Telemetry API として唯一公開されている API で、各イベントを受け取るための Subscriber の登録を行う API です。\n仕様については下記公式ドキュメントに記載されていますが、一部載っていない項目もあったのであらためてここで整理します。\nLambda Telemetry API reference - AWS Lambda メソッドとエンドポイント\nPUT http://${AWS_LAMBDA_RUNTIME_API}/2022-07-01/telemetry リクエストヘッダ\nContent-Type: application/json Lambda-Extension-Identifier: POST /extension/register のレスポンスヘッダに含まれる ExtensionIdentifier リクエストボディ\nschemaVersion: 2022-07-01 (required) destination: Subscriber として起動しているサーバの情報 (required) protocol: プロトコル (HTTP or TCP) URI: アドレス (\u0026ldquo;URI\u0026rdquo; は小文字じゃなくて大文字) types: 受信したいイベントの種類の配列 (platform, function, extension) (required) buffering: Telemetry API 側でのイベントのバッファリング設定 (option) maxItems: 最大イベント数 maxBytes: 最大バイト数 timeoutMs: 最大秒数 (ミリ秒) 例 { \u0026#34;schemaVersion\u0026#34;: \u0026#34;2022-07-01\u0026#34;, \u0026#34;types\u0026#34;: [ \u0026#34;platform\u0026#34;, \u0026#34;function\u0026#34;, ], \u0026#34;buffering\u0026#34;: { \u0026#34;maxItems\u0026#34;: 1000, \u0026#34;maxBytes\u0026#34;: 262144, \u0026#34;timeoutMs\u0026#34;: 100 }, \u0026#34;destination\u0026#34;: { \u0026#34;protocol\u0026#34;: \u0026#34;HTTP\u0026#34;, \u0026#34;URI\u0026#34;: \u0026#34;http://sandbox.localdomain:8080\u0026#34; } } Subscribe API をコールする際に注意したいのは、まず destination.URI の値としてはドメインが sandbox.localdomain である必要があります。それ以外のドメインで指定した場合、下記のようなエラーになります。\nstatusCode:403\nerrType:Telemetry.AccessDenied\nerrMessage:Only \u0026lsquo;sandbox.localdomain\u0026rsquo; hostname is supported.\nまた、上記の公式ドキュメントでは Lambda-Extension-Identifier に関する記述がありませんが、設定しない もしくは値が不正な場合は下記のようなエラーになります。\nstatusCode:403\nerrType:Extension.InvalidExtensionIdentifier\nerrMessage:Invalid Lambda-Extension-Identifier\n2. Subscriber に対して送信されるイベントについて Telemetry API から送信されるイベントは、大きく分けて Platform event, Function logs, Extension logs の 3 つのカテゴリに分けられ、各カテゴリ内で更にいつかの Event type に分類されています。\nPlatform event platform.initStart platform.initRuntimeDone platform.initReport platform.start platform.runtimeDone platform.report platform.restoreStart platform.restoreRuntimeDone platform.restoreReport platform.extension platform.telemetrySubscription platform.logsDropped Function logs function Extension logs extension 各 Event type ごとに schema が定義されていますが、 Event 全体の schema としては下記のようになっています。\n{ \u0026#34;time\u0026#34;: \u0026#34;イベントの発生日時\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Event type\u0026#34;, \u0026#34;record\u0026#34;: \u0026#34;各 Event type の schema\u0026#34; } 例えば、 Extension が登録されて起動状態になったことを示すイベント platform.extension は下記のようなオブジェクトになります。\n{ \u0026#34;time\u0026#34;: \u0026#34;2022-10-12T00:02:15.000Z\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;platform.extension\u0026#34;, \u0026#34;record\u0026#34;: { \u0026#34;events\u0026#34;: [ \u0026#34;INVOKE\u0026#34;, \u0026#34;SHUTDOWN\u0026#34; ], \u0026#34;name\u0026#34;: \u0026#34;my-telemetry-extension\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Ready\u0026#34; } } その他、各 Event type の schema の詳細については下記の公式ドキュメントを参照してください。\nLambda Telemetry API Event schema reference - AWS Lambda Telemetry API を使う Extension を作ってみる では実際に Telemetry API を使う Extension を作ってみます。前回と同様に Go で実装します。\n今回作る Extension でやることは下記のとおりです。\nplatform と function のイベントを Subscribe する 受け取ったイベントの内容をログに出力する 以上です。\nExtension のメイン処理については前回と大きく変わらないので、 Telemetry API に関連するところだけ掻い摘んで説明します。\n実装の詳細については下記の GitHub リポジトリを参照してください。\naws-lambda-api-go/_examples/extension-using-telemetry-api at main · michimani/aws-lambda-api-go Telemetry API の Subscriber を起動 まずは、 Telemetry API からのイベントを受信してハンドリングするための Subscriber を起動します。\naws-lambda-api-go/subscriber.go at v0.2.0 · michimani/aws-lambda-api-go const defaultSubscriberPort = \u0026#34;1210\u0026#34; const address = \u0026#34;sandbox.localdomain:\u0026#34; + defaultSubscriberPort type TelemetryAPISubscriber struct { httpServer *http.Server logger *logger.Logger } func NewTelemetryAPISubscriber(l *logger.Logger) *TelemetryAPISubscriber { return \u0026amp;TelemetryAPISubscriber{ httpServer: nil, logger: l, } } func (s *TelemetryAPISubscriber) Start() (string, error) { s.logger.Info(\u0026#34;Starting on address:%s\u0026#34;, address) s.httpServer = \u0026amp;http.Server{Addr: address} http.HandleFunc(\u0026#34;/\u0026#34;, s.telemetryEventHandler) go func() { err := s.httpServer.ListenAndServe() if err != http.ErrServerClosed { s.logger.Error(\u0026#34;Unexpected stop on Http Server. err:%v\u0026#34;, err) s.Shutdown() } else { s.logger.Info(\u0026#34;Http Server closed. err:%v\u0026#34;, err) } }() return fmt.Sprintf(\u0026#34;http://%s/\u0026#34;, address), nil } TelemetryAPISubscriber を返す NewTelemetryAPISubscriber と、 TelemetryAPISubscriber のメソッドとして Start を実装しています。\nTelemetryAPISubscriber.Start で、 sandbox.localdomain:1210 のアドレスで HTTP サーバを起動しています。HTTP サーバでは / に対するリクエストを受けて、リクエスト (Telemetry API から送信されるイベント) をハンドリングする TelemetryAPISubscriber.telemetryEventHandler を実行するようにしています。\nサーバのアドレスはこのあとの Subscribe API をコールする際に必要になるので呼び出し元 (= Extension のメイン処理) に返します。\nSubscribe API をコールして Subscriber を登録 続いて、起動した Subscriber の情報と受信したいイベントを Subscribe API を使って登録します。\naws-lambda-api-go/client.go at v0.2.0 · michimani/aws-lambda-api-go func (c *Client) Subscribe(ctx context.Context, exId string, httpURI string) error { var bufTimeoutMs uint64 = 100 out, err := telemetry.Subscribe(ctx, c.alagoClient, \u0026amp;telemetry.SubscribeInput{ LambdaExtensionIdentifier: exId, DestinationProtocol: telemetry.DestinationProtocolHTTP, DestinationURI: httpURI, TelemetryTypes: []telemetry.TelemetryType{ telemetry.TelemetryTypeFunction, telemetry.TelemetryTypePlatform, }, BufferTimeoutMs: \u0026amp;bufTimeoutMs, }) if err != nil { c.logger.Error(\u0026#34;An error occurred at telemetrySubscribe. err:%v\u0026#34;, err) return err } if out.StatusCode != http.StatusOK { return fmt.Errorf(\u0026#34;An error occurred at extension registration. statusCode:%d errType:%s errMessage:%s\u0026#34;, out.StatusCode, out.Error.ErrorType, out.Error.ErrorMessage) } return nil } 今回も、クライントライブラリとして aws-lambda-api-go を使っています。\n受信するイベントは、 platform と function にしています。 (extension はイベントの数が多すぎたので除外しました)\nエラーがあれば呼び出し元に返す、ただそれだけの処理になっています。\nイベントのハンドリング 最後に、Telemetry API から送信されたイベントのハンドリング処理です。\naws-lambda-api-go/subscriber.go at v0.2.0 · michimani/aws-lambda-api-go type telemetryAPIEvent struct { Record any `json:\u0026#34;record\u0026#34;` Type string `json:\u0026#34;type\u0026#34;` Time time.Time `json:\u0026#34;time\u0026#34;` } func (s *TelemetryAPISubscriber) telemetryEventHandler(w http.ResponseWriter, r *http.Request) { body, err := io.ReadAll(r.Body) if err != nil { s.logger.Error(\u0026#34;Failed to reading body. err:%v\u0026#34;, err) return } var events []telemetryAPIEvent _ = json.Unmarshal(body, \u0026amp;events) s.logger.Info(\u0026#34;Received %d events.\u0026#34;, len(events)) for i, e := range events { s.logger.Info(\u0026#34;%d: Time:%s Type:%s Record:%v\u0026#34;, i, e.Time.Format(time.RFC3339Nano), e.Type, e.Record) } events = nil } 今回はイベントの大枠となる schema に対応する構造体 telemetryAPIEvent だけ用意して、各イベントごとの schema に対応する構造体の定義については省略しています。\nまた、ハンドリングと言っても今回はログに出力するだけなので、特に難しいことはしていません。\nLambda 関数で使ってみる 前回と同様に RIE を使ってローカルで試そうと思ったんですが、どうやら Telemetry API はまだ RIE (が含まれたコンテナイメージ) では対応していないようだった1ので実際の環境にデプロイして試してみました。\n準備 実際に Lambda で実行して確認するまでの準備として、 Extension と関数をビルドします。\nExtension については Lambda Layer として作成するので、下記コマンドで build -\u0026gt; zip 化します。\nGOOS=linux GOARCH=amd64 go build -o ../bin/extensions/telemetry-api-extension main.go chmod +x bin/extensions/telemetry-api-extension cd bin \u0026amp;\u0026amp; zip -r extension.zip extensions/ Lambda 関数についてはただログを出力する処理だけあればよさそうなので、下記のような内容で Python で実装しました。\nimport json import logging def lambda_handler(event, context): logger = logging.getLogger() logger.setLevel(logging.INFO) logger.info(\u0026#39;[%s] Hello Telemetry API!\u0026#39;, context.aws_request_id) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Hello from Lambda!\u0026#39;) } こちらも zip 化しておきます。\nzip function.zip main.py また、 Lambda 関数の作成時にアタッチする IAM Role が必要になるので、下記コマンドで作成しておきます。\n# IAM Role の作成 aws iam create-role \\ --role-name telemetry-api-function-role \\ --assume-role-policy-document \u0026#39;{\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\u0026#34;Statement\u0026#34;: [{ \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: {\u0026#34;Service\u0026#34;: \u0026#34;lambda.amazonaws.com\u0026#34;}, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;}]}\u0026#39; \\ --query \u0026#39;Role.Arn\u0026#39; \\ --output text # IAM Policy をアタッチ aws iam attach-role-policy \\ --role-name telemetry-api-function-role \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Extension と それを使う関数を作成 準備ができたので、 Extension (Lambda Layer) と Lambda 関数のリソースを作成します。\nExtension は Lambda Layer として作成するので、下記コマンドでデプロイします。\naws lambda publish-layer-version \\ --layer-name \u0026#39;telemetry-api-extension\u0026#39; \\ --zip-file \u0026#39;fileb://bin/extension.zip\u0026#39; \\ --region ap-northeast-1 Lambda 関数については、下記コマンドで作成します。中で AWS CLI コマンドを叩いていてややこしく見えますが、各 ARN 記述する必要がなく、アカウント ID に依存しない形になっています。\naws lambda create-function \\ --function-name \u0026#39;function-with-telemetry-api-extension\u0026#39; \\ --runtime \u0026#39;python3.9\u0026#39; \\ --handler \u0026#39;main.lambda_handler\u0026#39; \\ --role $( aws iam get-role \\ --role-name \u0026#39;telemetry-api-function-role\u0026#39; \\ --query \u0026#39;Role.Arn\u0026#39; \\ --output text) \\ --zip-file fileb://function.zip \\ --layers $( aws lambda list-layer-versions \\ --layer-name \u0026#39;telemetry-api-extension\u0026#39; \\ --query \u0026#39;LayerVersions[0].LayerVersionArn\u0026#39; \\ --output text) \\ --region ap-northeast-1 実行してログを確認 Extension を設定した Lambda 関数が作成できたので、下記コマンドで実行してみます。\naws lambda invoke \\ --function-name \u0026#39;function-with-telemetry-api-extension\u0026#39; \\ --invocation-type \u0026#39;RequestResponse\u0026#39; \\ --cli-binary-format \u0026#39;raw-in-base64-out\u0026#39; \\ --region \u0026#39;ap-northeast-1\u0026#39; \\ --log-type \u0026#39;Tail\u0026#39; \\ /dev/stdout \\ | jq -sr \u0026#39;.[1] | .LogResult\u0026#39; \\ | base64 -d 上記コマンドを実行すると、 Lambda 関数実行時のログが手元で確認できます。\n1[Telemetry API Extension Client] INFO: Succeeded to register extension. 2[Telemetry API Subscriber] INFO: Starting on address:sandbox.localdomain:1210 3TELEMETRY Name: telemetry-api-extension State: Subscribed Types: [function,platform] 4[Telemetry API Subscriber] INFO: Received 1 events. 5[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:21:53.222Z Type:platform.initStart Record:map[initializationType:on-demand phase:init] 6[Telemetry API Extension Client] INFO: Waiting for next event... 7[Telemetry API Subscriber] INFO: Received 1 events. 8[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:21:53.277Z Type:platform.telemetrySubscription Record:map[name:telemetry-api-extension state:Subscribed types:[function platform]] 9EXTENSION Name: telemetry-api-extension State: Ready Events: [SHUTDOWN,INVOKE] 10START RequestId: eded6372-e614-4305-8516-f2697c3acfbc Version: $LATEST 11[Telemetry API Extension Client] INFO: Received invoke event. awsRequestId:eded6372-e614-4305-8516-f2697c3acfbc invokedAt:2022-12-11 10:21:53.381772081 +0000 UTC 12[Telemetry API Extension Client] INFO: Waiting for next event... 13[INFO] 2022-12-11T10:21:53.382Z eded6372-e614-4305-8516-f2697c3acfbc [eded6372-e614-4305-8516-f2697c3acfbc] Hello Telemetry API! 14END RequestId: eded6372-e614-4305-8516-f2697c3acfbc 15REPORT RequestId: eded6372-e614-4305-8516-f2697c3acfbc Duration: 17.38 ms Billed Duration: 18 ms Memory Size: 128 MB Max Memory Used: 45 MB Init Duration: 157.98 ms なんとなく冒頭に書いたような順番で処理がされてそうなことがわかると思います。\n例えば、 1 行目の\n[Telemetry API Extension Client] INFO: Succeeded to register extension.\nでは、メッセージが示すとおり Extension の登録が完了したことがわかります。\nまた、 4-5 行目の\n[Telemetry API Subscriber] INFO: Received 1 events. [Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:21:53.222Z Type:platform.initStart Record:map\nでは、 Telemetry API から Platform に関するイベントを受け取っていることがわかります。\nとは言え、一度関数を実行しただけでは雰囲気が掴みづらいと思うので、何度か invoke-function コマンドを実行した後に、下記のコマンドで CloudWatch Logs に出力されたログを確認してみます。\naws logs get-log-events \\ --log-group-name /aws/lambda/function-with-telemetry-api-extension \\ --log-stream-name \u0026#34;$( aws logs describe-log-streams \\ --log-group-name /aws/lambda/function-with-telemetry-api-extension \\ --query \u0026#39;max_by(logStreams[], \u0026amp;lastEventTimestamp).logStreamName\u0026#39; \\ --output text)\u0026#34; \\ --limit 100 \\ --query \u0026#39;events[].message\u0026#39; \\ --output text 得られる出力は下記のようになります。\n1[Telemetry API Extension Client] INFO: Succeeded to register extension. 2[Telemetry API Subscriber] INFO: Starting on address:sandbox.localdomain:1210 3TELEMETRY\tName: telemetry-api-extension\tState: Subscribed\tTypes: [function,platform] 4[Telemetry API Extension Client] INFO: Waiting for next event... 5[Telemetry API Subscriber] INFO: Received 1 events. 6[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:32:46.331Z Type:platform.initStart Record:map[initializationType:on-demand phase:init] 7[Telemetry API Subscriber] INFO: Received 1 events. 8[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:32:46.389Z Type:platform.telemetrySubscription Record:map[name:telemetry-api-extension state:Subscribed types:[function platform]] 9EXTENSION\tName: telemetry-api-extension\tState: Ready\tEvents: [SHUTDOWN,INVOKE] 10START RequestId: e63295fe-c7a1-48c2-ada2-c7044c697c12 Version: $LATEST 11[Telemetry API Extension Client] INFO: Received invoke event. awsRequestId:e63295fe-c7a1-48c2-ada2-c7044c697c12 invokedAt:2022-12-11 10:32:46.510767828 +0000 UTC 12[Telemetry API Extension Client] INFO: Waiting for next event... 13[INFO]\t2022-12-11T10:32:46.511Z\te63295fe-c7a1-48c2-ada2-c7044c697c12\t[e63295fe-c7a1-48c2-ada2-c7044c697c12] Hello Telemetry API! 14END RequestId: e63295fe-c7a1-48c2-ada2-c7044c697c12 15REPORT RequestId: e63295fe-c7a1-48c2-ada2-c7044c697c12\tDuration: 16.30 ms\tBilled Duration: 17 ms\tMemory Size: 128 MB\tMax Memory Used: 46 MB\tInit Duration: 177.38 ms 16[Telemetry API Subscriber] INFO: Received 7 events. 17[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:32:46.507Z Type:platform.initRuntimeDone Record:map[initializationType:on-demand phase:init status:success] 18[Telemetry API Subscriber] INFO: 1: Time:2022-12-11T10:32:46.508Z Type:platform.extension Record:map[events:[SHUTDOWN INVOKE] name:telemetry-api-extension state:Ready] 19[Telemetry API Subscriber] INFO: 2: Time:2022-12-11T10:32:46.508Z Type:platform.initReport Record:map[initializationType:on-demand metrics:map[durationMs:176.689] phase:init] 20[Telemetry API Subscriber] INFO: 3: Time:2022-12-11T10:32:46.51Z Type:platform.start Record:map[requestId:e63295fe-c7a1-48c2-ada2-c7044c697c12 version:$LATEST] 21[Telemetry API Subscriber] INFO: 4: Time:2022-12-11T10:32:46.511Z Type:function Record:[INFO]\t2022-12-11T10:32:46.511Z\te63295fe-c7a1-48c2-ada2-c7044c697c12\t[e63295fe-c7a1-48c2-ada2-c7044c697c12] Hello Telemetry API! 22[Telemetry API Subscriber] INFO: 5: Time:2022-12-11T10:32:46.526Z Type:platform.runtimeDone Record:map[metrics:map[durationMs:15.686 producedBytes:53] requestId:e63295fe-c7a1-48c2-ada2-c7044c697c12 spans:[map[durationMs:1.26 name:responseLatency start:2022-12-11T10:32:46.510Z] map[durationMs:0.021 name:responseDuration start:2022-12-11T10:32:46.511Z]] status:success] 23[Telemetry API Subscriber] INFO: 6: Time:2022-12-11T10:32:46.532Z Type:platform.report Record:map[metrics:map[billedDurationMs:17 durationMs:16.295 initDurationMs:177.377 maxMemoryUsedMB:46 memorySizeMB:128] requestId:e63295fe-c7a1-48c2-ada2-c7044c697c12 status:success] 24START RequestId: 29fffe63-ae9a-4dce-ad28-0a2bd117e5fe Version: $LATEST 25[Telemetry API Extension Client] INFO: Received invoke event. awsRequestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe invokedAt:2022-12-11 10:32:49.885648337 +0000 UTC 26[Telemetry API Extension Client] INFO: Waiting for next event... 27[INFO]\t2022-12-11T10:32:49.885Z\t29fffe63-ae9a-4dce-ad28-0a2bd117e5fe\t[29fffe63-ae9a-4dce-ad28-0a2bd117e5fe] Hello Telemetry API! 28END RequestId: 29fffe63-ae9a-4dce-ad28-0a2bd117e5fe 29REPORT RequestId: 29fffe63-ae9a-4dce-ad28-0a2bd117e5fe\tDuration: 1.30 ms\tBilled Duration: 2 ms\tMemory Size: 128 MB\tMax Memory Used: 46 MB 30[Telemetry API Subscriber] INFO: Received 4 events. 31[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:32:49.885Z Type:platform.start Record:map[requestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe version:$LATEST] 32[Telemetry API Subscriber] INFO: 1: Time:2022-12-11T10:32:49.886Z Type:function Record:[INFO]\t2022-12-11T10:32:49.885Z\t29fffe63-ae9a-4dce-ad28-0a2bd117e5fe\t[29fffe63-ae9a-4dce-ad28-0a2bd117e5fe] Hello Telemetry API! 33[Telemetry API Subscriber] INFO: 2: Time:2022-12-11T10:32:49.886Z Type:platform.runtimeDone Record:map[metrics:map[durationMs:1.065 producedBytes:53] requestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe spans:[map[durationMs:0.791 name:responseLatency start:2022-12-11T10:32:49.885Z] map[durationMs:0.032 name:responseDuration start:2022-12-11T10:32:49.886Z]] status:success] 34[Telemetry API Subscriber] INFO: 3: Time:2022-12-11T10:32:49.887Z Type:platform.report Record:map[metrics:map[billedDurationMs:2 durationMs:1.3 maxMemoryUsedMB:46 memorySizeMB:128] requestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe status:success] 35[Telemetry API Extension Client] INFO: Received shutdown event. reason:spindown Telemetry API から送信されるイベントは Subscribe API をコールするときにリクエストボディにセットする buffering の設定に従ってバッファリングされるため実際のイベント発生時とは多少のラグがあります。ただ、 24-34 行目あたりは普段の Lambda 関数実行時に出力されるログと、Telemetry API のイベントとがわかりやすいかと思います。\n24START RequestId: 29fffe63-ae9a-4dce-ad28-0a2bd117e5fe Version: $LATEST 25[Telemetry API Extension Client] INFO: Received invoke event. awsRequestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe invokedAt:2022-12-11 10:32:49.885648337 +0000 UTC 26[Telemetry API Extension Client] INFO: Waiting for next event... 27[INFO]\t2022-12-11T10:32:49.885Z\t29fffe63-ae9a-4dce-ad28-0a2bd117e5fe\t[29fffe63-ae9a-4dce-ad28-0a2bd117e5fe] Hello Telemetry API! 28END RequestId: 29fffe63-ae9a-4dce-ad28-0a2bd117e5fe 29REPORT RequestId: 29fffe63-ae9a-4dce-ad28-0a2bd117e5fe\tDuration: 1.30 ms\tBilled Duration: 2 ms\tMemory Size: 128 MB\tMax Memory Used: 46 MB 30[Telemetry API Subscriber] INFO: Received 4 events. 31[Telemetry API Subscriber] INFO: 0: Time:2022-12-11T10:32:49.885Z Type:platform.start Record:map[requestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe version:$LATEST] 32[Telemetry API Subscriber] INFO: 1: Time:2022-12-11T10:32:49.886Z Type:function Record:[INFO]\t2022-12-11T10:32:49.885Z\t29fffe63-ae9a-4dce-ad28-0a2bd117e5fe\t[29fffe63-ae9a-4dce-ad28-0a2bd117e5fe] Hello Telemetry API! 33[Telemetry API Subscriber] INFO: 2: Time:2022-12-11T10:32:49.886Z Type:platform.runtimeDone Record:map[metrics:map[durationMs:1.065 producedBytes:53] requestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe spans:[map[durationMs:0.791 name:responseLatency start:2022-12-11T10:32:49.885Z] map[durationMs:0.032 name:responseDuration start:2022-12-11T10:32:49.886Z]] status:success] 34[Telemetry API Subscriber] INFO: 3: Time:2022-12-11T10:32:49.887Z Type:platform.report Record:map[metrics:map[billedDurationMs:2 durationMs:1.3 maxMemoryUsedMB:46 memorySizeMB:128] requestId:29fffe63-ae9a-4dce-ad28-0a2bd117e5fe status:success] 各行のログは下記のような情報を示しています。\nLambda 関数が Invoke された Extension API の GET /extension/event/next のレスポンスとして INVOKE イベントを取得 再度 Extension API の GET /extension/event/next をコールして次のイベントを待機 Lambda 関数の logger.info() が出力しているログ Lambda 関数の終了 Lambda 関数の実行レポート Subscriber が Telemetry API から、バッファリングされていた 4 つのイベントを受信した platform.start イベント (24 行目: Lambda 関数の Invoke に対応) function イベント (27 行目: Lambda 関数内でのログ出力に対応) platform.runtimeDone イベント (28 行目: Lambda 関数の終了に対応) platform.report イベント (29 行目: Lambda 関数の実行レポートに対応) 以上で、 Telemetry API によってどのようなイベントが取得できるのか、実際の Lambda 関数の実行と合わせて確認ができました。\nまとめ AWS Lambda の Telemetry API を使った Lambda Extension を作ってみた話でした。\nTelemetry API のリリース情報を見たときは「お、なんか凄そう？」という感想だけでしたが、実際にこれを使う Extension を作ってみてどのような挙動をするものなのか、理解ができた気がします。\n今回はただ受け取ったイベントをログとして出力するだけでしたが、例えば function イベントを取得して Lambda 関数が出力しているログの文字列を解析して独自のレポートを出力する みたいなことをやると面白そうだなと思います。\n弁護士ドットコム Advent Calendar 2022 、明日の担当は @shellme です。お楽しみに。\nSubscribe API をコールするところで 404 Page Not Found が返ってきました\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
    "permalink": "https://michimani.net/post/aws-lambda-extension-using-telemetry-api/",
    "title": "Telemetry API を使う Lambda Extension を作ってみた"
  },
  {
    "contents": "この記事は AWS LambdaとServerless Advent Calendar 2022 7 日目の記事です。\n最近 Lambda の Runtime API について調べていたところで Extension API というものもある事に気づきました。どうやら Lambda Extension を自作するときに使う API のようだったので、その API を使いたいがために実際に Lambda Extension を自作してみました。\nLambda Extension とは 実行環境のライフサイクルと Extension Init Invoke Shutdown Go で Lambda Extension を作ってみる 自作する Extension の概要 実装 Extension のメイン処理 POST /extension/register で実行環境に Extension を登録 GET /extension/event/next で次のイベントを取得・ハンドリング 自作した Extension を Lambda 関数で使う Extension の実行可能ファイルを作成 Lambda 関数のコード Dockerfile ローカルで起動して invoke まとめ Lambda Extension とは Lambda Extension (以下、 Extension) は、 Lambda 関数の Runtime の一部、もしくは実行環境内で独立したプロセスとして様々な機能を実行できる機能です。それぞれ、前者は内部拡張機能、後者は外部拡張機能と呼ばれ、この記事内で触れる Extension は後者の外部拡張機能を指すものとします。\nExtension は、 AWS が提供しているもの、 AWS Lambda パートナー 1 が提供しているもの、および今回紹介するように独自の Extension を作成して使用することができます。 最近だと AWS からリリースされた AWS Parameters and Secrets Lambda Extension 2 3 が注目されていました。\nLambda は実行環境上で関数を呼び出しますが、 Extension はその実行環境が作成される際に開始されます。\nそして、関数と同じ実行環境上で起動するため Extension 自体のパフォーマンス (初期化にかかる時間、処理時間、メモリ消費量など) は関数のパフォーマンスにも影響します。そのため、 Extension を自作する際には、そのあたりにも注意が必要です。\n参考: Lambda extensions - AWS Lambda 実行環境のライフサイクルと Extension Lambda の実行環境のライフサイクルには、 Init 、 Invoke 、 Shutdown という 3 つのフェーズがあります。各フェーズでは実行環境の作成や関数の Invoke、実行環境の破棄などを行い、 Extension は各フェーズで Extension API を使用して Runtime への登録や実行環境で発生するイベントの検知を行い、 Extension としての処理を実行します。\nsequenceDiagram participant c as Client participant ls as Lambda Service participant r as Runtime participant e as Extension alt Init ls -\u003e\u003e e: init extensions in /ops/extensions e -\u003e\u003e ls: POST /extension/register e -\u003e\u003e ls: GET /extension/event/next end loop alt Invoke c -\u003e\u003e ls: invoke ls -\u003e\u003e r: invoke ls -\u003e\u003e e: response of GET /extension/event/next (INVOKE event) r -\u003e\u003e ls: /response (Runtime API) ls -\u003e\u003e c: response e -\u003e\u003e ls: GET /extension/event/next end end alt Shutdown ls -\u003e\u003e r: SIGTERM ls -\u003e\u003e e: response of GET /extension/event/next (SHUTDOWN event) end Init 実行環境の作成 関数のハンドラ外部にあるコードの実行 所謂　\u0026ldquo;コールドスタート\u0026rdquo;　時に実行されるフェーズ Extension との関係 /opt/extensions ディレクトリ配下にある実行可能ファイルを Extension として解釈し、それらを並列で実行 (開始) 開始された Extension は Extension POST /extension/register Extension API をコールして Runtime に Extension を登録 Invoke 関数のハンドラを呼び出す = 関数の実行 Extension との関係 GET /extension/event/next Extension API をコールして Invoke イベントを取得 Shutdown 一定期間 Invoke されなかったときに実行されるフェーズ 独立したプロセスとして動く Extension を停止させた上で、実行環境を破棄 Extension との関係 GET /extension/event/next Extension API をコールして Shutdown イベントを取得 参考: Lambda Extensions API - AWS Lambda Go で Lambda Extension を作ってみる これまでの内容を踏まえて、実際に Extension を作ってみます。\nExtension は関数とは独立したプロセスとして実行されるため、実装する際に使用する言語は関数と合わせる必要はありません。今回は下記リポジトリの実装例を参考にして Go で実装してみます。\naws-samples/aws-lambda-extensions: A collection of sample extensions to help you get started with AWS Lambda Extensions 自作する Extension の概要 今回実装する Extension でやりたいことは、下記のとおりです。\n同一実行環境で Invoke された関数に対応する Request ID をメモリ上に保持する 関数から任意のタイミングで Extension に対して GET リクエストを送ることで、保持している Request ID の一覧を取得できる 1 は、 Lambda の Invoke フェーズにて Invoke イベントを検知して、そのイベント内に含まれる Request ID をメモリ上に保持します。\n2 は、 Extension のサブプロセス (goroutine) として HTTP API サーバを起動し、 特定のエンドポイントに対するリクエストのレスポンスとしてメモリ上に保持している Request ID のリストを JSON 形式で返します。\nシーケンス図にするとこんな感じです。\nsequenceDiagram participant c as Client participant ls as Lambda Service participant r as Runtime participant f as Function participant e as Extension participant m as On Memory participant s as Extension's HTTP API Server alt Init ls -\u003e\u003e e: init e -\u003e\u003e ls: POST /extension/register e -\u003e\u003e s: start e -\u003e\u003e m: init invocation history e -\u003e\u003e ls: GET /extension/event/next end loop alt Invoke c -\u003e\u003e ls: invoke ls -\u003e\u003e r: invoke ls -\u003e\u003e e: response of GET /extension/event/next (INVOKE event) e -\u003e\u003e m: save Request ID to history e -\u003e\u003e ls: GET /extension/event/next r -\u003e\u003e f: execute main handler f -\u003e\u003e s: GET localhost:1203/invocations s -\u003e\u003e m: read history m -\u003e\u003e s: s -\u003e\u003e f: {\"invocations\": [{\"awsRequestId\":\"id1\", \"invocatedAt\":\"2022-12-04T00:15:06.992783032Z\"}]} f -\u003e\u003e r: r -\u003e\u003e ls: /response (Runtime API) ls -\u003e\u003e c: response end end alt Shutdown ls -\u003e\u003e r: SIGTERM ls -\u003e\u003e e: response of GET /extension/event/next (SHUTDOWN event) end 実装 実装したものは下記リポジトリに置いています。\nmichimani/invocation-history-extension: This is a Extension for AWS Lambda Function that records history of invocation at the same runtime environment. この記事内では、主に Extension API を利用するところについて触れます。\nExtension のメイン処理 main.go#main では下記の処理を順に実行しています。\nExtension API をコールするための Context を生成 シグナルハンドリング用の goroutine を起動 Extension API POST /extension/register をコールして実行環境に Extension を登録 Invocation の履歴を返す HTTP API サーバを起動 Extension API GET /extension/event/next をコールして各イベントをハンドリングする処理を開始 1,2,4 は特に目新しいポイントはないので、 3 と 4 について 各 Extension API の仕様とともに実装を見ていきます。\nPOST /extension/register で実行環境に Extension を登録 実行環境のライフサイクルと Extension の関係のところで書いたとおり、 Extension のコードが実行されたときに Extension API の /extension/register エンドポイントに POST リクエストを送ることで Extension を登録する必要があります。\nこの API ではリクエストヘッダおよびリクエストボディに必須の項目があります。\nまず、リクエストヘッダの Lambda-Extension-Name には Extension の名前をセットする必要があります。セットする値は、 Extension の実行可能ファイルのファイル名です。今回の Extension の場合、 invocation-history-extension というファイル名で /opt/extensions 配下に実行ファイルを配置するようにしているので invocation-history-extension を値としてセットします。\n次にリクエストボディですが、この Extension でハンドリングしたいイベントを配列で指定します。 イベントの種類は INVOKE と SHUTDOWN のみで、今回は両方のイベントをハンドリングしたいので両方指定します。\nAPI のレスポンスヘッダ Lambda-Extension-Identifier には登録が完了した結果として一意な値が設定されています。この値は後にコールする API のリクエストヘッダにセットする必要があるので保持しておきます。\nExtension API を実行するには単純に HTTP リクエストを送信すればよいのですが、今回はその部分を aws-lambda-api-go というクライアントライブラリを 自作 使用して実装します。\nmichimani/aws-lambda-api-go: This is a client library for Go language to use AWS Lambda\u0026amp;rsquo;s Runtime API, Extension API, Telemetry API, and Logs API. import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/michimani/aws-lambda-api-go/alago\u0026#34; \u0026#34;github.com/michimani/aws-lambda-api-go/extension\u0026#34; ) type Client struct { alagoClient *alago.Client logger *Logger extensionIdentifier string } func (c *Client) Register(ctx context.Context, extensionName string) error { out, err := extension.Register(ctx, c.alagoClient, \u0026amp;extension.RegisterInput{ LambdaExtensionName: extensionName, Events: []extension.EventType{ extension.EventTypeInvoke, extension.EventTypeShutdown, }, }) if err != nil { return fmt.Errorf(\u0026#34;An expected error occurred at extension registration. err:%v\u0026#34;, err) } if out.StatusCode != http.StatusOK { return fmt.Errorf(\u0026#34;An error occurred at extension registration. statusCode:%d errType:%s errMessage:%s\u0026#34;, out.StatusCode, out.Error.ErrorType, out.Error.ErrorMessage) } c.logger.Info(\u0026#34;Succeeded to register extension.\u0026#34;) c.extensionIdentifier = out.LambdaExtensionIdentifier return nil } クライアントライブラリの extension.Register 関数に対して extension.RegisterInput に Extension の名前とハンドリングしたいイベントをセットして渡すだけで POST /extension/register API をコールすることができます。簡単ですね。\nAPI のレスポンスは extension.RegisterOutput として取得できるので、 RegisterOutput.LambdaExtensionIdentifier の値を保持しておきます。\n参考: Lambda Extensions API | Register - AWS Lambda GET /extension/event/next で次のイベントを取得・ハンドリング 実行環境のライフサイクルと Extension の関係のところで書いたとおり、 Lambda の実行環境は関数の invoke および実行環境の破棄時にそれぞれ INVOKE と SHUTDOWN のイベントを発行します。発行します、と書きましたが、実際には GET /extension/event/next API がリクエストをブロックして、実行環境からイベントが発行されるタイミングでレスポンスが返るという動きになります。なので、この API をコールするための http.Client のタイムアウトは長め (もしくは 0) にしておく必要があります。\nこの API は、 Register API のレスポンスヘッダ Lambda-Extension-Identifier に含まれていた値をリクエストヘッダ Lambda-Extension-Identifier にセットしてコールします。リクエストボディは不要です。\nこちらも Register と同じクライアントライブラリを使って、イベントのハンドリングと合わせて下記のように実装しています。\nfunc (c *Client) PollingEvent(ctx context.Context) (bool, error) { c.logger.Info(\u0026#34;Waiting for next event...\u0026#34;) out, err := extension.EventNext(ctx, c.alagoClient, \u0026amp;extension.EventNextInput{ LambdaExtensionIdentifier: c.extensionIdentifier, }) if err != nil { return false, err } if out.StatusCode != http.StatusOK { return false, fmt.Errorf(\u0026#34;An error occurred at calling /extension/event/next API. statusCode:%d errType:%s errMessage:%s\u0026#34;, out.StatusCode, out.Error.ErrorType, out.Error.ErrorMessage) } switch out.EventType { case eventTypeInvoke: now := time.Now().UTC() saveInvocationHistory(out.RequestID, \u0026amp;now) c.logger.Info(\u0026#34;Succeeded to save new history. awsRequestId:%s invokedAt:%v\u0026#34;, out.RequestID, now) case eventTypeShutdown: c.logger.Info(\u0026#34;Received shutdown event. reason:%s\u0026#34;, out.ShutdownReason) c.logger.Info(\u0026#34;Truncate invocation history.\u0026#34;) for _, h := range History.Invocations { c.logger.Info(\u0026#34;%+v\u0026#34;, *h) } return false, nil default: return false, fmt.Errorf(\u0026#34;Cannot handle event. eventType:%s\u0026#34;, out.EventType) } return true, nil } イベントの種類が INVOKE のときは、レスポンスに含まれる Request ID をメモリ上に保存しています。 一方、イベントの種類が SHUTDOWN のときは、それまでに保存していた Request ID をすべてログに出力するようにしています。\nメソッド名にもあるように、実質イベントをポーリングしているような処理になるので、このメソッドの返り値としては bool と error を返すようにしていて、 bool が true であれば呼び出し元 (今回であれば main.go#processEvents) で再度このメソッドを実行してポーリングを始めるような形にしています。\n参考: Lambda Extensions API | Next - AWS Lambda 自作した Extension を Lambda 関数で使う では、自作した Extension を実際に使ってみます。\nExtension の利用方法としては下記の 3 通りがあります。\nLambda Layer として publish して使う Lambda 関数のコードと一緒に zip に同梱して使う コンテナイメージに同梱して使う 今回はコンテナイメージに同梱してローカル環境で自作 Extension を使ってみます。コンテナイメージにすることで RIE を使ってローカル環境でも実際の Lambda の実行環境に近い形で動作確認ができます。4\nExtension の実行可能ファイルを作成 まずは Extension を実行可能ファイルとして用意します。\n今回は Go で実装したので、下記コマンドでビルドして実行可能ファイルを生成し、 zip 化します。\nGOOS=linux GOARCH=amd64 go build -o bin/extensions/invocation-history-extension main.go \\ \u0026amp;\u0026amp; chmod +x bin/extensions/invocation-history-extension \\ \u0026amp;\u0026amp; cd bin \\ \u0026amp;\u0026amp; zip -r extension.zip extensions/ もしくは、今回実装した Extension については GitHub の Releases から zip でダウンロードできるので、そちらから取得してきます。\nReleases · michimani/invocation-history-extension Lambda 関数のコード 今回実装した Extension は localhost:1203 で HTTP API サーバを起動しているので、そこにリクエストを送ってそのレスポンスを関数のレスポンスとするような Lambda 関数を用意します。\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; runtime \u0026#34;github.com/aws/aws-lambda-go/lambda\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/lambdacontext\u0026#34; ) type Response struct { Message string `json:\u0026#34;message\u0026#34;` Invocations []invocation `json:\u0026#34;invocations\u0026#34;` } func handleRequest(ctx context.Context) (*Response, error) { log.Println(\u0026#34;start handler\u0026#34;) defer log.Println(\u0026#34;end handler\u0026#34;) lc, ok := lambdacontext.FromContext(ctx) if !ok { return nil, fmt.Errorf(\u0026#34;Failed to get Lambda context from context.\u0026#34;) } history, err := getInvocationHistory() if err != nil { return nil, err } return \u0026amp;Response{ Message: fmt.Sprintf(\u0026#34;Current request ID is %s\u0026#34;, lc.AwsRequestID), Invocations: history, }, nil } func init() { log.Println(\u0026#34;cold start\u0026#34;) } func main() { runtime.Start(handleRequest) } // Struct of response from Invocation History Extension - GET /invocations API type resultFromExtension struct { Invocations []invocation `json:\u0026#34;invocations\u0026#34;` } type invocation struct { AWSRequestID string `json:\u0026#34;awsRequestId\u0026#34;` InvocatedAt *time.Time `json:\u0026#34;invocatedAt\u0026#34;` } const invocationsEndpoint = \u0026#34;http://localhost:1203/invocations\u0026#34; // Get invocation history from Invocation History Extension IPC. func getInvocationHistory() ([]invocation, error) { req, err := http.NewRequestWithContext(context.Background(), \u0026#34;GET\u0026#34;, invocationsEndpoint, nil) if err != nil { return nil, err } // call Extension API client := http.Client{} res, err := client.Do(req) if err != nil { return nil, err } defer res.Body.Close() buf := new(bytes.Buffer) if _, err := buf.ReadFrom(res.Body); err != nil { return nil, err } bodyString := buf.String() if res.StatusCode != http.StatusOK { return nil, fmt.Errorf(\u0026#34;Failed to get invocation history by using extension. statusCode:%d body:%s\u0026#34;, res.StatusCode, bodyString) } exRes := resultFromExtension{} if err := json.Unmarshal([]byte(bodyString), \u0026amp;exRes); err != nil { return nil, err } return exRes.Invocations, nil } 別プロセスで起動している Extension の HTTP API サーバに GET リクエストを送信し、そのレスポンスに現在の Request ID を付与したものを関数のレスポンスとして返すような実装になっています。具体的なレスポンスの内容はこのあと確認します。\nDockerfile Extension をコンテナイメージに同梱する場合は Extension の実行可能なファイルをイメージ内の /opt/extensions 以下に配置すればよいので、下記のような Dockerfile を作成することで Extension を同梱したイメージを作成することができます。\nFROM public.ecr.aws/lambda/provided:al2 as build RUN yum install -y golang unzip RUN go env -w GOPROXY=direct ADD go.mod go.sum ./ RUN go mod download ADD . . RUN go build -o /main RUN mkdir -p /opt ## ここは GitHub から直接取得するようにしてもよい # ADD https://github.com/michimani/invocation-history-extension/releases/download/v0.2.0/extension.zip ./ ADD ./bin/extension.zip ./ RUN unzip extension.zip -d /opt RUN rm extension.zip FROM public.ecr.aws/lambda/provided:al2 COPY --from=build /main /main COPY entry.sh / RUN chmod 755 /entry.sh RUN mkdir -p /opt/extensions WORKDIR /opt/extensions COPY --from=build /opt/extensions . ENTRYPOINT [ \u0026#34;/entry.sh\u0026#34; ] CMD [\u0026#34;/main\u0026#34;] AWS やパートナーから提供されている Extension で実行可能ファイルそのものが公開されていない場合、コンテナイメージとして公開されているものがあればそれを使えばよくて、 Lambda Layer として公開されているものについては下記の AWS CLI コマンドを実行することで zip 形式で Extension をダウンロードすることができます。 (AWS Parameters And Secrets Lambda Extension の場合)\ncurl $( aws lambda get-layer-version-by-arn \\ --arn \u0026#39;arn:aws:lambda:ap-northeast-1:133490724326:layer:AWS-Parameters-and-Secrets-Lambda-Extension:2\u0026#39; \\ --query \u0026#39;Content.Location\u0026#39; \\ --output text ) --output extension.zip その後 unzip して実行可能なファイルのみをコンテナイメージに同梱すれば、自作した Extension と同様にコンテナイメージで使用することができます。\nローカルで起動して invoke Dockerfile の準備もできたので、あとは docker build して docker run すればローカルで Lambda の実行環境が起動します。\ndocker build -t invocation-history-ex-func:local . \\ \u0026amp;\u0026amp; docker run \\ --rm \\ -p 9000:8080 \\ invocation-history-ex-func:local これで localhost:9000 で Lambda の実行環境が起動しているので、そこに対して curl でリクエストを送って invoke します。\ncurl \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ http://localhost:9000/2015-03-31/functions/function/invocations すると下記のようなレスポンスが得られます。\n{ \u0026#34;message\u0026#34;: \u0026#34;Current request ID is e65d6f55-2335-47e9-88f9-a851e7d539d5\u0026#34;, \u0026#34;invocations\u0026#34;: [ { \u0026#34;awsRequestId\u0026#34;: \u0026#34;e65d6f55-2335-47e9-88f9-a851e7d539d5\u0026#34;, \u0026#34;invocatedAt\u0026#34;: \u0026#34;2022-12-06T13:25:52.447847893Z\u0026#34; } ] } 続けて invoke すると\n{ \u0026#34;message\u0026#34;: \u0026#34;Current request ID is 4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f\u0026#34;, \u0026#34;invocations\u0026#34;: [ { \u0026#34;awsRequestId\u0026#34;: \u0026#34;e65d6f55-2335-47e9-88f9-a851e7d539d5\u0026#34;, \u0026#34;invocatedAt\u0026#34;: \u0026#34;2022-12-06T13:25:52.447847893Z\u0026#34; }, { \u0026#34;awsRequestId\u0026#34;: \u0026#34;4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f\u0026#34;, \u0026#34;invocatedAt\u0026#34;: \u0026#34;2022-12-06T13:27:17.244096344Z\u0026#34; } ] } それまでに同じ実行環境で invoke された際の Request ID が履歴となって保持されていることがわかります。\nLambda の実行環境が出力しているログは下記のようになっています。\n1START RequestId: e65d6f55-2335-47e9-88f9-a851e7d539d5 Version: $LATEST 206 Dec 2022 13:25:52,433 [INFO] (rapid) External agent invocation-history-extension (c96c9db2-076e-4ac7-9572-f98d4091d0e8) registered, subscribed to [INVOKE SHUTDOWN] 3[Invocation History Extension] INFO: Succeeded to register extension. 4[Invocation History Extension] INFO: Waiting for next event... 52022/12/06 13:25:52 cold start 62022/12/06 13:25:52 start handler 7[Invocation History Extension] INFO: Succeeded to save new history. awsRequestId:e65d6f55-2335-47e9-88f9-a851e7d539d5 invokedAt:2022-12-06 13:25:52.447847893 +0000 UTC 8[Invocation History Extension] INFO: Waiting for next event... 92022/12/06 13:25:52 end handler 10END RequestId: e65d6f55-2335-47e9-88f9-a851e7d539d5 11REPORT RequestId: e65d6f55-2335-47e9-88f9-a851e7d539d5 Init Duration: 0.22 ms Duration: 28.23 ms Billed Duration: 29 ms Memory Size: 3008 MB Max Memory Used: 3008 MB 12START RequestId: 4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f Version: $LATEST 132022/12/06 13:27:17 start handler 14[Invocation History Extension] INFO: Succeeded to save new history. awsRequestId:4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f invokedAt:2022-12-06 13:27:17.244096344 +0000 UTC 15[Invocation History Extension] INFO: Waiting for next event... 162022/12/06 13:27:17 end handler 17END RequestId: 4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f 18REPORT RequestId: 4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f Duration: 1.53 ms Billed Duration: 2 ms Memory Size: 3008 MB Max Memory Used: 3008 MB 1 〜 11 行目が 1 回目の invoke によるログで、このときのみ Register API を実行したログが出力されていることがわかります。\nこの状態から ctr + C で実行環境のプロセスを終了させると下記のようなログが出力されます。\n^C06 Dec 2022 13:31:54,898 [INFO] (rapid) Received signal signal=interrupt 06 Dec 2022 13:31:54,898 [INFO] (rapid) Shutting down... 06 Dec 2022 13:31:54,898 [WARNING] (rapid) Reset initiated: SandboxTerminated [Invocation History Extension] INFO: Received shutdown event. reason:SandboxTerminated [Invocation History Extension] INFO: Truncate invocation history. [Invocation History Extension] INFO: {AWSRequestID:e65d6f55-2335-47e9-88f9-a851e7d539d5 InvocatedAt:2022-12-06 13:25:52.447847893 +0000 UTC} [Invocation History Extension] INFO: {AWSRequestID:4a61a5dc-7bbf-43cb-abd0-67ed0388cf5f InvocatedAt:2022-12-06 13:27:17.244096344 +0000 UTC} 06 Dec 2022 13:31:54,899 [INFO] (rapid) runtime exited ローカル環境ではプロセス終了 = 実行環境の破棄となります。出力されているログからも、 SHUTDOWN イベントを受け取ってハンドリングされていることがわかります。\nまとめ AWS Lambda の Extension API を使ってみたいがために Lambda Extension を自作してみた話でした。\nLambda Extension を自作してみて Extension API がやっていること、 Lambda の実行環境上での Extension のライフサイクル、 Lambda そのもののライフサイクルについて完全に理解できた気がします。\nと言っても Extension API にはまだ Init Error API と Exit Error API があり、今回はそれらを使っていません。また、 Lambda には Extension API の他にも Runtime API、 Telemetry API (Logs API) もあり、まだまだ何もわからない部分がたくさんありそうです。\n個人的に一時期 Lambda 熱が冷めていたんですが、最近また温まってきたので今後はこのあたりの API 群を追っていこうかなと思います。\nAWS Lambda 拡張機能パートナー - AWS Lambda \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAWS Parameters and Secrets Lambda Extension を発表 \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSSM Parameter Store および Secrets Manager への問い合わせをキャッシュすることで再取得時のレイテンシーおよびコストを削減できるという機能\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nコンテナイメージを使った Lambda 関数のあれこれ - michimani.net \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
    "permalink": "https://michimani.net/post/aws-lambda-extension-written-in-go/",
    "title": "AWS Lambda の Extension API を使いたいがために Go で Lambda Extension を自作してみた"
  },
  {
    "contents": "Lambda 関数のパッケージタイプとしてコンテナイメージを指定できるようになってからもう 2 年が経とうとしています。最近になってちゃんと触るようになって色々わかってきたことがあるので、やったことをまとめておきます。\nコンテナイメージを使った Lambda 関数の概要 Dockerfile AWS ベースイメージを使う 代替ベースイメージを使う ローカル環境での実行 RIE によるローカルでの実行 イベントの再現 コールドスタートとウォームスタート Lambda Runtime API の利用 Lambda Layer (Extension) の利用 CI/CD 基本的な更新方法 CI/CD を構築する際の注意点 GitHub Actions による CI/CD Lambda Layer (Extension) の使い方 概要 Parameter and Secret Lambda Extension を使ったサンプル Extension のバイナリ取得 コンテナイメージの作成 実装 Extension を使った場合のログ まとめ コンテナイメージを使った Lambda 関数の概要 まずは概要です。\nと言っても難しいことはなく、\nパッケージタイプとして Image を、 ImageURI として ECR Repository のイメージ URI を指定します コンテナイメージを使う場合はランタイムは指定しません 指定できるコンテナイメージの最大サイズは 10 GB となっています くらいです。\nその他の Lambda 関数の機能 (環境変数、 Layer (Extension) など) については、従来の Lambda 関数と同等です。\nDockerfile Lambda 関数用のコンテナイメージを作成する際、ベースとなるイメージは AWS が提供しているベースイメージを使う方法と、 alpine などの代替イメージを使う方法があります。それぞれメリット・デメリットがあるので簡単にまとめておきます。\nまた、今回は前提として Go で実装されたコードをもとにイメージを作成します。なので、下記ディレクトリ構成と main.go が存在していることとします。\n. ├── Dockerfile ├── entry.sh ├── go.mod ├── go.sum └── main.go package main import ( \u0026#34;log\u0026#34; runtime \u0026#34;github.com/aws/aws-lambda-go/lambda\u0026#34; ) type Response struct { Message string `json:\u0026#34;message\u0026#34;` } func handleRequest() (Response, error) { log.Println(\u0026#34;start handler\u0026#34;) defer log.Println(\u0026#34;end handler\u0026#34;) return Response{ Message: \u0026#34;Hello AWS Lambda\u0026#34;, }, nil } func init() { log.Println(\u0026#34;cold start\u0026#34;) } func main() { runtime.Start(handleRequest) } AWS ベースイメージを使う AWS ベースイメージを使う場合は下記のような Dockerfile になります。\nFROM public.ecr.aws/lambda/provided:al2 as build RUN yum install -y golang RUN go env -w GOPROXY=direct ADD go.mod go.sum ./ RUN go mod download ADD . . RUN go build -o /main FROM public.ecr.aws/lambda/provided:al2 COPY --from=build /main /main ENTRYPOINT [\u0026#34;/main\u0026#34;] AWS ベースイメージは ECR Public で公開されているので、 docker build するには ECR にログインしている必要があります。\nAWS ベースイメージには、 Lambda Layer (Extension) を使用するための機構やローカルで実行するための RIE (Runtime Interface Emulator) も含まれており、ビルド後のイメージサイズは大きくなります。\n後述しますが、 RIE だけをイメージに含めることもできるので、 AWS ベースイメージを使うシチュエーションとしては Lambda Layer (Extension) を使いたい場面となりそうです。\n代替ベースイメージを使う 代替のベースイメージ (今回は alpine) を使う場合は下記のような Dockerfile になります。\nFROM alpine as build RUN apk add go git RUN go env -w GOPROXY=direct ADD go.mod go.sum ./ RUN go mod download ADD . . RUN go build -o /main FROM alpine COPY --from=build /main /main ENTRYPOINT [ \u0026#34;/main\u0026#34; ] ベースに使うイメージのサイズにもよりますが、必要最低限の構成となるため AWS ベースイメージを使う場合と比較してビルド後のイメージサイズは小さくなります。\nイメージサイズが小さくなる分、 Lambda Layer (Extension) は使用できず、ローカルでの実行もできません。\nLambda Layer (Extension) を使用しない場合、AWS ベースイメージの代わりに代替となるベースイメージを使うことでイメージサイズを小さくできます。\nとはいえローカルでの実行はできたほうが嬉しいので、その場合は下記のように RIE だけを追加するような Dockerfile を用意します。\nFROM alpine as build RUN apk add go git RUN go env -w GOPROXY=direct ADD go.mod go.sum ./ RUN go mod download ADD . . RUN go build -o /main FROM alpine COPY --from=build /main /main ADD https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie /usr/bin/aws-lambda-rie RUN chmod 755 /usr/bin/aws-lambda-rie COPY entry.sh / RUN chmod 755 /entry.sh ENTRYPOINT [ \u0026#34;/entry.sh\u0026#34; ] CMD [ \u0026#34;/main\u0026#34; ] ここで出てくる entry.sh は下記の内容とします。\n#!/bin/sh if [ -z \u0026#34;${AWS_LAMBDA_RUNTIME_API}\u0026#34; ]; then exec /usr/bin/aws-lambda-rie \u0026#34;$@\u0026#34; else exec \u0026#34;$@\u0026#34; fi ローカル環境での実行 コンテナイメージを使った Lambda 関数はローカル環境での実行も容易です。\nRIE によるローカルでの実行 ローカル環境での実行には RIE (Runtime Interface Emulator) を使用します。\n前項で書いたように AWS ベースイメージを使用するか、代替ベースイメージに RIE を追加することでローカル環境で Lambda 関数を実行することができます。\nコンテナイメージ内に RIE が含まれている場合、下記の手順でローカルでの起動・実行が可能です。\ndocker build\ndocker build -t container-lambda-function:local . docker run\ndocker run \\ --rm \\ -p 9000:8080 \\ container-lambda-function:local (ポートは任意)\nコンテナを起動すると、 Lambda 関数が実行されるのではなく、実行可能な状態になります。\n標準出力には下記のようなログが出力されます。\n03 Nov 2022 13:39:12,623 [INFO] (rapid) exec \u0026#39;/main\u0026#39; (cwd=/var/task, handler=) invoke\n実際に Lambda 関数を実行するには、\nhttp://localhost:9000/2015-03-31/functions/function/invocations に対して GET もしくは POST リクエストを送ります。\ncurl \u0026#39;http://localhost:9000/2015-03-31/functions/function/invocations\u0026#39; curl のレスポンスとしては下記のような出力が得られます。\n{\u0026#34;message\u0026#34;:\u0026#34;Hello AWS Lambda\u0026#34;} また、起動しているコンテナイメージの標準出力では、下記のような出力が得られます。\nSTART RequestId: b8a7e4ed-381d-4925-8a7a-48a90a4dd2e4 Version: $LATEST 2022/11/03 13:44:08 cold start 2022/11/03 13:44:08 start handler 2022/11/03 13:44:08 end handler END RequestId: b8a7e4ed-381d-4925-8a7a-48a90a4dd2e4 REPORT RequestId: b8a7e4ed-381d-4925-8a7a-48a90a4dd2e4 Init Duration: 0.34 msDuration: 10.43 ms Billed Duration: 11 ms Memory Size: 3008 MB Max Memory Used: 3008 MB これは実際の Lambda 関数が出力するログと同等の内容になっています。\n一方で、 RIE はイメージ内に含めずにローカル環境にインストールして使用することもできます。1 ただ、開発者のローカル環境に RIE をインストールしてもらうのは面倒なので、コンテナイメージ内に含めてしまうのが良いかなと思います。\nローカル環境に RIE をインストールしてそれを使う場合、コンテナ起動時のコマンドが下記のようになります。\ndocker run -d -v ~/.aws-lambda-rie/aws-lambda \\ --entrypoint /aws-lambda/aws-lambda-rie \\ -p 9000:8080 \\ container-lambda-function:local イベントの再現 Lambda 関数の実行時には API Gateway からの Payload、 S3 や SQS 等からのイベントを受け取ることがあります。\nローカル環境でそれらの受け取りを再現するには、 curl でのリクエスト時にメソッドを POST に、イベントの JSON をリクエストボディに入れることで再現できます。\n例えば、 SQS 駆動の Lambda 関数を再現したい場合は、下記のようなリクエストを送ります。\ncurl -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;Records\u0026#34;: [{\u0026#34;messageId\u0026#34;: \u0026#34;message-id\u0026#34;, \u0026#34;eventSource\u0026#34;: \u0026#34;event-source\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;{\\\u0026#34;key\\\u0026#34;: \\\u0026#34;value\\\u0026#34;}\u0026#34;}]}\u0026#39; \\ \u0026#39;http://localhost:9000/2015-03-31/functions/function/invocations\u0026#39; SQS 駆動の Lambda 関数の実装例はこちら。\nsqs-lambda-example/lambda at main · michimani/sqs-lambda-example コールドスタートとウォームスタート Lambda 関数の特徴として、コールドスタートとウォームスタートがあります。\nコンテナイメージを使った Lambda 関数のローカル実行ではこれらの再現も可能です。\n具体的な動作としては、 docker run でコンテナを起動してから最初に curl でリクエスト送った際の実行はコールドスタートとなり、それ以降はウォームスタートの挙動となります。起動中のコンテナを停止して起動しなおせば、またコールドスタートの挙動を確認できます。\n例であげている Go のコードでは、コールドスタート時のみ init() 関数が実行され、それ以降は実行されないことが確認できます。\nコールドスタート時のログ。\nSTART RequestId: b8a7e4ed-381d-4925-8a7a-48a90a4dd2e4 Version: $LATEST 2022/11/03 13:44:08 cold start 2022/11/03 13:44:08 start handler 2022/11/03 13:44:08 end handler END RequestId: b8a7e4ed-381d-4925-8a7a-48a90a4dd2e4 REPORT RequestId: b8a7e4ed-381d-4925-8a7a-48a90a4dd2e4 Init Duration: 0.34 msDuration: 10.43 ms Billed Duration: 11 ms Memory Size: 3008 MB Max Memory Used: 3008 MB ウォームスタート時のログ。\nSTART RequestId: d5016f63-3648-423c-bb7a-597548b83da1 Version: $LATEST 2022/11/03 14:00:20 start handler 2022/11/03 14:00:20 end handler END RequestId: d5016f63-3648-423c-bb7a-597548b83da1 REPORT RequestId: d5016f63-3648-423c-bb7a-597548b83da1 Duration: 1.41 ms Billed Duration: 2 ms Memory Size: 3008 MB Max Memory Used: 3008 MB コールドスタート時には init() 関数内で出力しているログがあり、さらに Init Duration の情報も出力されていますが、ウォームスタート時にはそれらがありません。\nLambda 関数のこの挙動によって DB へのコネクションが増え続ける罠がありますが、それについてもローカル環境で再現することができます。\nmichimani/lambda-rdb-test: In this repository, you can try to see how the number of DB connections changes depending on the implementation method when connecting to RDB from Lambda functions implemented in Go. Lambda Runtime API の利用 Lambda には Lambda Runtime API 2 というものが用意されており、実行中の Lambda 関数に関する情報を取得したり、動作を与えることができます。 RIE を使ったローカル実行では、Lambda Runtime API の挙動についても確認することができます。\nLambda Runtime API のエンドポイントは、Lambda 関数実行時に自動的に設定される AWS_LAMBDA_RUNTIME_API という環境変数に設定されており、 RIE を使ったローカル実行時にもこの環境変数は設定されています。\nGo では下記のような実装によって、実行中の Lambda 関数の Request ID を取得することができます。\nconst ( runtimeAPIEnvKey = \u0026#34;AWS_LAMBDA_RUNTIME_API\u0026#34; runtimeRequestIDHeaderName = \u0026#34;Lambda-Runtime-Aws-Request-Id\u0026#34; ) func getRequestID(client *http.Client) (string, error) { host := os.Getenv(runtimeAPIEnvKey) if host == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;host is empty\u0026#34;) } url := fmt.Sprintf(\u0026#34;http://%s/2018-06-01/runtime/invocation/next\u0026#34;, host) req, err := http.NewRequestWithContext(context.Background(), \u0026#34;GET\u0026#34;, url, nil) if err != nil { return \u0026#34;\u0026#34;, err } res, err := client.Do(req) if err != nil { return \u0026#34;\u0026#34;, err } rHeader := res.Header rIds, exists := rHeader[runtimeRequestIDHeaderName] if !exists { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;\u0026#39;%s\u0026#39; header does not exists.\u0026#34;, runtimeRequestIDHeaderName) } if len(rIds) == 0 { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Value of \u0026#39;%s\u0026#39; header is empty.\u0026#34;, runtimeRequestIDHeaderName) } return rIds[0], nil } 関数全体の実装はこちら。\nbase-of-lambda-container-image/main.go at main · michimani/base-of-lambda-container-image Lambda Layer (Extension) の利用 Lambda には Lambda Layer (Extension) という機能があります。ローカル実行ではこの機能の挙動も確認することができます。これに関しては後述します。\nCI/CD コンテナイメージを使った Lambda 関数の CI/CD について考えてみます。\n従来の Lambda 関数であれば、該当バージョンのコード一式を zip 化して S3 Bucket にアップロードし、 lambda update-function-code にてソースとなるコードをしてい\n基本的な更新方法 従来の Lambda 関数であれば、該当バージョンのコード一式を zip 化して更新、もしくは zip を S3 Bucket にアップロードして更新していましたが、コンテナイメージを使った Lambda の場合はフローが異なります。\nまず、変更後のコードでコンテナイメージを作成し、 ECR Repository に push します。 そして、 lambda update-function-code で ImageURI を更新します。\nこのときの URI はハッシュ付き URI でもよいですが、 latest 等のタグ付き URI でも可です。むしろ、タグ付き URI を使って更新したほうが、リソースを CFn や Terraform で管理している場合には差分が発生しないのでおすすめです。\nタグ付き URI で更新した場合でも、実際に利用されるイメージのハッシュ付き URI については lambda get-function で確認することができます。\naws lambda get-function \\ --function-name \u0026#39;lambda-parameters-extension-function\u0026#39; \\ --query \u0026#39;Code\u0026#39; | grep Uri \u0026#34;ImageUri\u0026#34;: \u0026#34;000000000000.dkr.ecr.ap-northeast-1.amazonaws.com/container-lambda-function:latest\u0026#34;, \u0026#34;ResolvedImageUri\u0026#34;: \u0026#34;000000000000.dkr.ecr.ap-northeast-1.amazonaws.com/container-lambda-function@sha256:c0b63302fa2ad2a78e6da8b37b8d4394c1b231a0963d82abd06d37dd4fd66277\u0026#34; 更新したあとは、実行基盤が変わってコールドスタートとなるタイミングから新しいコードでの実行となります。\nCI/CD を構築する際の注意点 コンテナイメージを使った Lambda 関数関連のリソースを定義する際には、いくつか依存関係がありリソース作成に関しては下記の順序で実施する必要があります。\nECR Repository を作成 Lambda 関数のコードを実装 ECR Repository に push Lambda 関数のリソースを作成 (対象となる ECR Repository にイメージが存在している必要があるため) CI/CD パイプラインを作成する際にも上記に注意しながら順番にリソースを定義していく必要があります。具体的には、まずは ECR に push するところまでのパイプラインを作って一度実行し、その後に関数を更新するステップを追加する、といった段階を踏むことになります。\nGitHub Actions による CI/CD コンテナイメージを使った Lambda 関数の更新を GitHub Actions で実施する場合の実装例です。\ndev ブランチへの push で dev 環境用の Lambda 関数を、 main ブランチへの push で production 環境用の Lambda 関数を、それぞれ更新するようなサンプルになっています。\nmichimani/container-lambda-cicd: コンテナイメージを利用する Lambda 関数の CI/CD のサンプル。 認証情報については、予め作成しておいた IAM Role の ARN のリポジトリの Secrets に設定しておいて、 yaml 内では ${{ secrets.ASSUME_ROLE_ARN }} で使用します。外部から設定が必要な情報はそれだけです。\nLambda Layer (Extension) の使い方 コンテナイメージを使用した Lambda 関数での Lambda Layer (Extension) の使い方についてです。\n概要 従来の Lambda 関数では、マネジメントコンソールから Layer を選択、もしくは Lambda リソース内の Layers に使用したいレイヤーを指定すればよかったですが、コンテナイメージを使用した Lambda 関数ではこの方法では使えません。\n方法としては、使用したい Layer (Extension) のバイナリをコンテナイメージに含めることで実現します。 配置するディレクトリも決まっており、 /opt/extensions 配下にバイナリを配置します。\nLayer (Extension) については AWS 公式/3rd party 問わずコンテナイメージとして公開されているものもありますが、公開されていないものもあります。コンテナイメージとして公開されていない AWS 公式の Layer (Extension) に関しては、対処の Layer (Extension) の ARN をもとに lambda get-layer-version-by-arn で取得できます。\n他の注意点として、 Dockerfile のところでも触れましたが、 Layer (Extension) を使用したい場合は AWS が提供しているベースイメージを使用する必要があります。\n具体的な方法については下記の AWS 公式ブログに記載されています。\nコンテナイメージ内でLambda レイヤーと拡張機能を動作させる | Amazon Web Services ブログ Parameter and Secret Lambda Extension を使ったサンプル 例として、先日発表されていた Parameter and Secret Lambda Extension をコンテナイメージを使用する Lambda 関数で使う場合を考えます。\nExtension のバイナリ取得 まずは Extension のバイナリを取得します。\nParameter and Secret Lambda Extension の ARN については下記の公式ドキュメントに記載されています。\nUse AWS Secrets Manager secrets in AWS Lambda functions - AWS Secrets Manager 東京 (ap-northeast-1) リージョンの ARN は\narn:aws:lambda:ap-northeast-1:133490724326:layer:AWS-Parameters-and-Secrets-Lambda-Extension:2\nなので、下記コマンドで zip 形式の Extension を取得します。\ncurl $( aws lambda get-layer-version-by-arn \\ --arn \u0026#39;arn:aws:lambda:ap-northeast-1:133490724326:layer:AWS-Parameters-and-Secrets-Lambda-Extension:2\u0026#39; \\ --query \u0026#39;Content.Location\u0026#39; --output text ) --output ps-ex.zip AWS 公式ブログ内では Dockerfile 内に記述されていましたが、 アクセスキーやシークレットを Dockerfile 内に記述したり環境変数で渡したりするのが面倒だった (直球) ので、ローカル環境にダウンロードしてくる方法をとっています。\nコンテナイメージの作成 下記のような Dockerfile でコンテナイメージを作成します。まずはローカルでの実行を想定しているため entry.sh を含めるようにしています。\n1FROM public.ecr.aws/lambda/provided:al2 as build 2RUN yum install -y golang unzip 3RUN go env -w GOPROXY=direct 4ADD go.mod go.sum ./ 5RUN go mod download 6ADD . . 7RUN go build -o /main 8RUN mkdir -p /opt 9ADD ./ps-ex.zip ./ 10RUN unzip ps-ex.zip -d /opt 11RUN rm ps-ex.zip 12 13FROM public.ecr.aws/lambda/provided:al2 14COPY --from=build /main /main 15COPY entry.sh / 16RUN chmod 755 /entry.sh 17RUN mkdir -p /opt/extensions 18WORKDIR /opt/extensions 19COPY --from=build /opt/extensions . 20ENTRYPOINT [ \u0026#34;/entry.sh\u0026#34; ] 21CMD [\u0026#34;/main\u0026#34;] 8-11 行目で、ローカルにダウンロードした Extension の zip をビルド用のステージに追加し unzip しています。\nそして 18-19 行目で、最終的に作成されるイメージの /opt/extensions ディレクトリに Extension のバイナリを配置しています。\n実装 Parameter and Secret Lambda Extension は http://localhost:2773 でリクエストを受け付けているので、下記のような実装で利用します。\nconst ( // Endpoint for getting parameter by Parameters and Secrets Lambda Extension. exGetParameterEndpoint = \u0026#34;http://localhost:2773/systemsmanager/parameters/get\u0026#34; // Header key of secret token secretTokenHeaderKey = \u0026#34;X-Aws-Parameters-Secrets-Token\u0026#34; // Query parameter key queryParameterKeyForName = \u0026#34;name\u0026#34; queryParameterKeyForVersion = \u0026#34;version\u0026#34; ) // Struct of response from AWSParametersAndSecretsLambdaExtension API type resultFromExtension struct { Parameter struct { ARN string DateType string LastModifiedDate time.Time Name string Selector string SourceResult *string Type string Value string Version int } ResultMetadata any } // Get a value using Parameters and Secrets Lambda Extension. func getValueByUsingExtension(key string, version int) (string, error) { // Get a value from extension // https://docs.aws.amazon.com/systems-manager/latest/userguide/ps-integration-lambda-extensions.html query := url.Values{} query.Add(queryParameterKeyForName, key) query.Add(queryParameterKeyForVersion, fmt.Sprintf(\u0026#34;%d\u0026#34;, version)) queryStr := query.Encode() url := fmt.Sprintf(\u0026#34;%s?%s\u0026#34;, exGetParameterEndpoint, queryStr) req, err := http.NewRequestWithContext(context.Background(), \u0026#34;GET\u0026#34;, url, nil) if err != nil { return \u0026#34;\u0026#34;, err } // set X-Aws-Parameters-Secrets-Token header req.Header.Add(secretTokenHeaderKey, os.Getenv(\u0026#34;AWS_SESSION_TOKEN\u0026#34;)) // call Extension API client := http.Client{} res, err := client.Do(req) if err != nil { return \u0026#34;\u0026#34;, err } defer res.Body.Close() buf := new(bytes.Buffer) if _, err := buf.ReadFrom(res.Body); err != nil { return \u0026#34;\u0026#34;, err } bodyString := buf.String() if res.StatusCode != http.StatusOK { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Failed to get parameter by using extension. statusCode:%d body:%s\u0026#34;, res.StatusCode, bodyString) } exRes := resultFromExtension{} if err := json.Unmarshal([]byte(bodyString), \u0026amp;exRes); err != nil { return \u0026#34;\u0026#34;, err } return exRes.Parameter.Value, nil } Extension を使った場合のログ Extension を使った場合、コールドスタート時に下記のようなログが確認できます。\n[AWS Parameters and Secrets Lambda Extension] 2022/11/03 15:20:32 PARAMETERS_SECRETS_EXTENSION_LOG_LEVEL is not present. Log level set to info. [AWS Parameters and Secrets Lambda Extension] 2022/11/03 15:20:32 INFO Systems Manager Parameter Store and Secrets Manager Lambda Extension 1.0.94 [AWS Parameters and Secrets Lambda Extension] 2022/11/03 15:20:32 INFO Serving on port 2773 詳細な実装サンプルについてはこちら。\nmichimani/lambda-parameters-extension: Sample code of using Parameter and Secret Lambda Extension. まとめ コンテナイメージを使った Lambda 関数について、最近触っていてわかったことなどをまとめてみました。\nLambda 関数は便利で利用できる場面も多い反面、ローカルでの動作確認が (SAM 等のツールを別途インストールする必要があったりで) 面倒な印象でした。\nそれが、コンテナイメージを使うことで (実際には RIE を使用することで) 実際の環境とほぼ同じような挙動を確認することができるという点が、個人的には一番嬉しいです。\nこの一点だけでもコンテナイメージ Lambda を使う価値はあるかなと思っています。\n他には、CI/CD に関しても イメージをビルドして ECR に push するところまでは ECS タスクの場合と同じなので、そのあたりの共通化 (もしくはほぼ流用) ができるというのも嬉しいポイントです。\nということで、コンテナイメージを使った Lambda 関数はいいぞ。\nコンテナイメージを使用して Go Lambda 関数をデプロイする - AWS Lambda \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAWS Lambda ランタイム API - AWS Lambda \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
    "permalink": "https://michimani.net/post/aws-lambda-function-with-container-image/",
    "title": "コンテナイメージを使った Lambda 関数のあれこれ"
  },
  {
    "contents": "CloudFront から S3 へのアクセスを制御する方法として Origin Access Identity (OAI) という機能がありましたが、それに代わる機能として Origin Access Control (OAC) という機能が発表されました。今回は、 AWS CLI を使って OAI を利用していたものを OAC に移行する方法について書きます。\n移行方法 AWS CLI でやっていく 1. 対象の S3 Bucket の Bucket Policy に、 Origin Access Identity の Statement を残したまま Origin Access Control の Statement を追記する 現在の Bucket Policy ドキュメントを取得する Origin Access Control による制御の Statement を追記する Bucket Policy を更新する 2. Origin Access Control のリソースを作成する always (推奨設定) never no-override 3. 対象の Distribution に設定する 4. 対象の S3 Bucket の Bucket Policy から Origin Access Identity の Statement を削除する 5. 不要になった Origin Access Identity のリソースを削除する まとめ 移行方法 基本的には下記の公式ドキュメントに沿って移行していきます。\nRestricting access to an Amazon S3 origin - Amazon CloudFront 具体的な手順としては、\n対象の S3 Bucket の Bucket Policy に、 Origin Access Identity の Statement を残したまま Origin Access Control の Statement を追記する Origin Access Control のリソースを作成する 対象の Distribution に設定する 対象の S3 Bucket の Bucket Policy から Origin Access Identity の Statement を削除する 不要になった Origin Access Identity のリソースを削除する となります。\nAWS CLI でやっていく 今回は、上記の手順を AWS CLI を使ってやってみます。\n必要な AWS CLI のバージョンは、 v1 は 1.25.60 以降、 v2 は 2.7.27 以降です。今回は v2 を使います。\n❯ aws --version aws-cli/2.7.27 Python/3.9.11 Darwin/21.6.0 exe/x86_64 prompt/off 作業するにあたっては、対象の S3 Bucket の名前と CloudFront の Distribution ID が必要なので、それぞれ環境変数に設定しておきます。\nBUCKET_NAME=\u0026#39;your-bucket-name\u0026#39; DIST_ID=\u0026#39;your-distribution-id\u0026#39; 1. 対象の S3 Bucket の Bucket Policy に、 Origin Access Identity の Statement を残したまま Origin Access Control の Statement を追記する 現在の Bucket Policy ドキュメントを取得する aws s3api get-bucket-policy \\ --bucket \u0026#34;${BUCKET_NAME}\u0026#34; \\ --output text \\ | jq . \u0026gt; bucket-policy.json OAI による制御の Statement として下記のような設定がされています。\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;OriginAccessIdentityStatement\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity your-distribution-id\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34;, \u0026#34;arn:aws:s3:::your-bucket-name\u0026#34; ] } ] } Origin Access Control による制御の Statement を追記する 上記の JSON を下記のように編集します。(Distribution ARN のアカウント ID は読み替えてください)\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ + { + \u0026#34;Sid\u0026#34;: \u0026#34;OriginAccessControlStatement\u0026#34;, + \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, + \u0026#34;Principal\u0026#34;: { + \u0026#34;Service\u0026#34;: \u0026#34;cloudfront.amazonaws.com\u0026#34; + }, + \u0026#34;Action\u0026#34;: [ + \u0026#34;s3:GetObject\u0026#34;, + \u0026#34;s3:ListBucket\u0026#34; + ], + \u0026#34;Resource\u0026#34;: [ + \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34;, + \u0026#34;arn:aws:s3:::your-bucket-name\u0026#34; + ], + \u0026#34;Condition\u0026#34;: { + \u0026#34;StringEquals\u0026#34;: { + \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:aws:cloudfront::000000000000:distribution/your-distribution-id\u0026#34; + } + } + }, { \u0026#34;Sid\u0026#34;: \u0026#34;OriginAccessIdentityStatement\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity your-origin-access-identity-id\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34;, \u0026#34;arn:aws:s3:::your-bucket-name\u0026#34; ] } ] } Bucket Policy を更新する aws s3api put-bucket-policy \\ --bucket \u0026#34;${BUCKET_NAME}\u0026#34; \\ --policy file://bucket-policy.json 問題ないはずですが、一応この時点でちゃんとアクセスできることを確認します。\n2. Origin Access Control のリソースを作成する Origin Access Control リソースの作成には、新たに追加された cloudfront コマンドの create-origin-access-control サブコマンドを使います。\n❯ aws cloudfront create-origin-access-control help ... SYNOPSIS create-origin-access-control --origin-access-control-config \u0026lt;value\u0026gt; [--cli-input-json | --cli-input-yaml] [--generate-cli-skeleton \u0026lt;value\u0026gt;] [--debug] [--endpoint-url \u0026lt;value\u0026gt;] [--no-verify-ssl] [--no-paginate] [--output \u0026lt;value\u0026gt;] [--query \u0026lt;value\u0026gt;] [--profile \u0026lt;value\u0026gt;] [--region \u0026lt;value\u0026gt;] [--version \u0026lt;value\u0026gt;] [--color \u0026lt;value\u0026gt;] [--no-sign-request] [--ca-bundle \u0026lt;value\u0026gt;] [--cli-read-timeout \u0026lt;value\u0026gt;] [--cli-connect-timeout \u0026lt;value\u0026gt;] [--cli-binary-format \u0026lt;value\u0026gt;] [--no-cli-pager] [--cli-auto-prompt] [--no-cli-auto-prompt] ... パラメータがいくつかありますが、今回は yaml ファイルを作って --cli-input-yaml で渡してリソースを作ってみます。\nそのために、ベースとなる yaml を生成します。\naws cloudfront create-origin-access-control \\ --generate-cli-skeleton yaml-input \u0026gt; oac.yaml 中身はこんな感じで、必須のパラメータのみ記載されています。\nOriginAccessControlConfig: # [REQUIRED] Contains the origin access control. Name: \u0026#39;\u0026#39; # [REQUIRED] A name to identify the origin access control. Description: \u0026#39;\u0026#39; # [REQUIRED] A description of the origin access control. SigningProtocol: sigv4 # [REQUIRED] The signing protocol of the origin access control, which determines how CloudFront signs (authenticates) requests. Valid values are: sigv4. SigningBehavior: never # [REQUIRED] Specifies which requests CloudFront signs (adds authentication information to). Valid values are: never, always, no-override. OriginAccessControlOriginType: s3 # [REQUIRED] The type of origin that this origin access control is for. Valid values are: s3. なので、中身を埋めます。\nOriginAccessControlConfig: Name: \u0026#39;OriginAccessControlForMyBlog\u0026#39; Description: \u0026#39;Origin Access Control for my blog.\u0026#39; SigningProtocol: sigv4 SigningBehavior: always OriginAccessControlOriginType: s3 Name, Description については任意の文字列を入れます。\nSigningProtocol にはそのまま sigv4 を、 OriginAccessControlOriginType にもそのまま s3 を入れます。\nSigningBehavior については、下記公式ドキュメントの Advanced settings for origin access control の部分を確認し、 always, never, no-override のいずれかを入れます。\nRestricting access to an Amazon S3 origin | Advanced settings for origin access control - Amazon CloudFront それぞれの設定について、公式ドキュメントの内容を要約してみます。\nalways (推奨設定) CloudFront が Origin (S3 Bucket) に送信するすべてのリクエストに署名します。\nnever CloudFront が Origin (S3 Bucket) に送信するすべてのリクエストに署名しません。これはつまり、この Origin Access Control を使用する Distribution のすべての Origin に対して アクセスコントロールをオフにします。\nこの設定をする場合、 Originとなる S3 Bucket には Public に公開されている必要があります。公開されていない Bucket に対してこの設定を行うと、 CloudFront は Origin にアクセスできず、 Viewer にはエラーを返します。\nno-override Viewer リクエストに Authorization ヘッダが存在する場合はそれを Origin リクエストに使用し、含まれていない場合は CloudFront が署名します。\nこの設定を使用する場合、 Viewer からの Authorization ヘッダを Origin リクエストで使用するためにキャッシュポリシーで Authorization ヘッダを許可する必要があります。\n以上から、基本的には always で設定しておけば良さそうです。\n作った yaml をもとに、 Origin Access Control のリソースを作成します。作成結果として ID が後に必要になるので控えておきます。\naws cloudfront create-origin-access-control \\ --cli-input-yaml file://oac.yaml \\ --query \u0026#39;OriginAccessControl.Id\u0026#39; \\ --output text 3. 対象の Distribution に設定する 続いて、作成した Origin Access Control を Distribution に設定します。 これは cloudfront の update-distribution という、どデカイ更新を行うサブコマンドで実施します。\nまずは現状の Distribution の設定を yaml で取得し、中身を変更して update-distribution で投げます。\naws cloudfront get-distribution-config \\ --id \u0026#34;${DIST_ID}\u0026#34; \\ --output yaml \\ \u0026gt; dist-config.yaml 100 行を超える yaml が生成されるので、その中の Origins の設定を下記のように変更します。このとき、 Origin Access Identity のリソースは後に削除するので、 your-oai-id の部分を環境変数に設定しておきます。 (OAI_ID='your-oai-id')\n+ OriginAccessControlId: your-oac-id S3OriginConfig: - OriginAccessIdentity: origin-access-identity/cloudfront/your-oai-id + OriginAccessIdentity: \u0026#39;\u0026#39; また、 ETag フィールドの 値はそのままで フィールド名を IfMatch に変更します。\n- ETag: HOGEHOGEVALUE + IfMatch: HOGEHOGEVALUE 下記コマンドで更新します。\naws cloudfront update-distribution \\ --id \u0026#34;${DIST_ID}\u0026#34; \\ --cli-input-yaml file://dist-config.yaml この時点でアクセスできていれば、既に Origin Access Control による制御への移行は成功しています。\n4. 対象の S3 Bucket の Bucket Policy から Origin Access Identity の Statement を削除する Bucket Policy 内の Origin Access Identity の Statement は不要になったので削除します。\n1 の手順で使った bucket-policy.json を下記のように変更し、 put-bucket-policy で更新します。\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;OriginAccessControlStatement\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;cloudfront.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34;, \u0026#34;arn:aws:s3:::your-bucket-name\u0026#34; ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:aws:cloudfront::000000000000:distribution/your-distribution-id\u0026#34; } } - }, - { - \u0026#34;Sid\u0026#34;: \u0026#34;OriginAccessIdentityStatement\u0026#34;, - \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, - \u0026#34;Principal\u0026#34;: { - \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity your-origin-access-identity-id\u0026#34; - }, - \u0026#34;Action\u0026#34;: [ - \u0026#34;s3:GetObject\u0026#34;, - \u0026#34;s3:ListBucket\u0026#34; - ], - \u0026#34;Resource\u0026#34;: [ - \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34;, - \u0026#34;arn:aws:s3:::your-bucket-name\u0026#34; - ] } ] } aws s3api put-bucket-policy \\ --bucket \u0026#34;${BUCKET_NAME}\u0026#34; \\ --policy file://bucket-policy.json 5. 不要になった Origin Access Identity のリソースを削除する 不要になった Origin Access Identity のリソースは cloudfront コマンドの delete-cloud-front-origin-access-identity コマンドで削除します。\naws cloudfront delete-cloud-front-origin-access-identity \\ --id \u0026#34;${OAI_ID}\u0026#34; \\ --if-match $( aws cloudfront get-cloud-front-origin-access-identity \\ --id ${OAI_ID} \\ --query \u0026#39;ETag\u0026#39; \\ --output text) まとめ Amazon CloudFront の新しいアクセスコントロール機能である Origin Access Control への移行を AWS CLI でやってみた話でした。\nTerraform も次の 4.29.0 で対応されそうなので、対応されたら試してみます。\n",
    "permalink": "https://michimani.net/post/aws-migrate-cloudfront-oai-to-oac/",
    "title": "AWS CLI で CloudFront の OAI を OAC に移行する"
  },
  {
    "contents": "最近 Go 言語で AWS CDK を使っているのですが、 L1 Constructs (low-level constructs) での記述に関する情報が見つけられず苦戦したので、メモとして残しておきます。\n目次 前提 L1 Constructs が必要な理由 リソース指定しない、または固定値で指定する場合 特定のプレフィックスを持つ Stack を対象リソースとする場合 L1 Constructs を使用したリソースの定義方法 まとめ 前提 今回は、先日リリースされた CloudFormation Stack のイベントを SNS 経由でメール通知する構成を AWS CDK v2 (Go) で構築してみます。\n作成する主なリソースは下記のとおりです。\nSNS::Topic SNS::TopicPolicy Events::Rule また、通知されるのは 特定のプレフィックスを持つ Stack のみ を対象にしたいと思います。\nL1 Constructs が必要な理由 今回の構成で L1 Constructs が必要になる理由は、 EventPattern で Resources を指定する際に、 prefix 演算子を使用したいからです。\nEventPattern ではワイルドカード (*) による値のマッチができず1、今回の要件である 特定のプレフィックスを持つ Stack のみ を対象としたい場合は prefix 演算子を使用する必要があります。2 この prefix 演算子を使用するか否かで、 L1 Constructs による実装が必要か否かが決まります。\n具体的にどのような違いになるのか見ていきます。\nリソース指定しない、または固定値で指定する場合 まず、 EventPattern として指定する JSON のスキーマおよび記述方法は下記のようになります。\n{ \u0026#34;detail-type\u0026#34;: [ \u0026#34;CloudFormation Resource Status Change\u0026#34;, \u0026#34;CloudFormation Stack Status Change\u0026#34;, \u0026#34;CloudFormation Drift Detection Status Change\u0026#34; ], \u0026#34;resources\u0026#34;: [ \u0026#34;arn:aws:cloudformation:ap-northeast-1:000000000000:stack/TestStack_Red\u0026#34;, \u0026#34;arn:aws:cloudformation:ap-northeast-1:000000000000:stack/TestStack_Green\u0026#34;, \u0026#34;arn:aws:cloudformation:ap-northeast-1:000000000000:stack/TestStack_Blue\u0026#34; ] } 一方、 AWS CDK (Go) の L2 Constructs で EventPattern の定義に使用する awsevents.EventPattern 構造体の定義は下記のとおりです。(上記の JSON と対応する部分のみ。全体は pkg.go.dev を参照。)\ntype EventPattern struct { DetailType *[]*string `field:\u0026#34;optional\u0026#34; json:\u0026#34;detailType\u0026#34; yaml:\u0026#34;detailType\u0026#34;` Resources *[]*string `field:\u0026#34;optional\u0026#34; json:\u0026#34;resources\u0026#34; yaml:\u0026#34;resources\u0026#34;` } Resources は *string のスライスとして定義されているので、設定したい JSON のスキーマと一致しています。なので、固定のリソースを対象とする、もしくはリソースを指定しない場合は L2 Constructs で定義することができます。 (対象のリソースを指定しない場合は EventPattern.Resources を省略すればよいだけです)\n特定のプレフィックスを持つ Stack を対象リソースとする場合 特定のプレフィックスを持つ Stack を対象リソースとする場合、 EventPattern の JSON は prefix 演算子を使用して下記のような記述になります。\n{ \u0026#34;detail-type\u0026#34;: [ \u0026#34;CloudFormation Resource Status Change\u0026#34;, \u0026#34;CloudFormation Stack Status Change\u0026#34;, \u0026#34;CloudFormation Drift Detection Status Change\u0026#34; ], \u0026#34;resources\u0026#34;: [ { \u0026#34;prefix\u0026#34;: \u0026#34;arn:aws:cloudformation:ap-northeast-1:000000000000:stack/TestStack\u0026#34; } ] } prefix 演算子を使わない場合とは異なり、 resources 配列の中身が文字列ではなくオブジェクトになっています。なので、 L2 Constructs ではこの JSON を表現することができず、 L1 Constructs を使用する必要が出てきます。\nL1 Constructs を使用したリソースの定義方法 ではここで本題の、 AWS CDK (Go) で L1 Constructs を使用してリソースを定義する方法について見ていきます。\n結論として、 *map[string]interface{} 型で定義します。\n先ほどの prefix 演算子を使用した JSON を表現するには、下記のように EventPattern を定義します。\neventPattern := \u0026amp;map[string]interface{}{ \u0026#34;detail-type\u0026#34;: \u0026amp;[]*string{ jsii.String(\u0026#34;CloudFormation Resource Status Change\u0026#34;), jsii.String(\u0026#34;CloudFormation Stack Status Change\u0026#34;), jsii.String(\u0026#34;CloudFormation Drift Detection Status Change\u0026#34;), }, \u0026#34;resources\u0026#34;: \u0026amp;[]interface{}{ \u0026amp;map[string]*string{ \u0026#34;prefix\u0026#34;: jsii.String(\u0026#34;arn:aws:cloudformation:ap-northeast-1:000000000000:stack/TestStack\u0026#34;), }, }, } L1 Constructs だと awsevents.CfnRuleProps.EventPattern が interface{} 型になるので、 *map[string]interface{} 型のスライスとして実装することで単純な文字列や prefix などの演算子を使用したオブジェクト型での指定が可能になります。\nこれを awsevents.CfnRule の定義と合わせると、下記のようになります。\nawsevents.NewCfnRule(scope, jsii.String(\u0026#34;CloudFormationEventsRule\u0026#34;), \u0026amp;awsevents.CfnRuleProps{ Name: jsii.String(util.ToKebabCase(\u0026#34;cloud-formation-events-rule\u0026#34;)), EventBusName: jsii.String(\u0026#34;default\u0026#34;), State: jsii.String(\u0026#34;ENABLED\u0026#34;), EventPattern: \u0026amp;map[string]interface{}{ \u0026#34;detail-type\u0026#34;: \u0026amp;[]*string{ jsii.String(\u0026#34;CloudFormation Resource Status Change\u0026#34;), jsii.String(\u0026#34;CloudFormation Stack Status Change\u0026#34;), jsii.String(\u0026#34;CloudFormation Drift Detection Status Change\u0026#34;), }, \u0026#34;region\u0026#34;: \u0026amp;[]*string{ region, }, \u0026#34;resources\u0026#34;: \u0026amp;[]interface{}{ \u0026amp;map[string]*string{ \u0026#34;prefix\u0026#34;: jsii.String(\u0026#34;arn:aws:cloudformation:ap-northeast-1:000000000000:stack/TestStack\u0026#34;), }, }, }, Targets: \u0026amp;[]interface{}{ \u0026amp;map[string]*string{ \u0026#34;arn\u0026#34;: jsii.String(\u0026#34;arn:aws:sns:ap-northeast-1:000000000000:TestTopic\u0026#34;), \u0026#34;id\u0026#34;: jsii.String(\u0026#34;Target0\u0026#34;), }, }, }) まとめ AWS CDK v2 で Go 言語を使用した場合の L1 Constructs によるリソースの定義方法について書きました。\nv2 で Go がサポートされたとはいえ TypeScript での利用が大多数のようで、なかなか Go を利用した場合の情報がなく大変だったんですが、完全に理解した気がします。\n今回の内容を使ったその他のリソースも合わせた実装例は下記リポジトリに置いていますので、参考になれば幸いです。\naws-cdk-go-examples/cloudformation-events-to-slack at main · michimani/aws-cdk-go-examples EventBridge ルール用のカスタムイベントパターンを作成する \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n他にも数値の範囲によるマッチなどが可能 Amazon EventBridge のイベントパターン - Amazon EventBridge \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
    "permalink": "https://michimani.net/post/aws-use-aws-cdk-l1-constructs-with-golang/",
    "title": "AWS CDK v2 (Go) で L1 Constructs を使う"
  },
  {
    "contents": "Terraform とOpenSearch CLI で OpenSearch Service に入門してみたので、そのメモです。\n目次 やること とりあえず試したい Terraform で OpenSearch Service のドメインを定義する ドメイン ドメインポリシー variables.tf を作成して apply OpenSearch CLI でリクエストを投げる OpenSearch CLI のインストール プロファイルの設定 Read Only なロールでリクエストを投げてみる Write も許可されてたロールでリクエストを投げてみる まとめ やること Terraform で OpenSearch Service のドメインを定義する エンジンは OpenSearch v1.x ドメインポリシーで OpenSearch に対してのリクエストを制限する 構築した OpenSearch クラスタに OpenSearch CLI でリクエストを投げる 異なる IAM ロールで認証して、ドメインポリシーの挙動を確認する とりあえず試したい 以降は↑の内容を順番に書いていくだけなので、もし実際に試したいという方は下記リポジトリを clone して試してみてください。 terraform/README.md を読んでもらえれば諸々試せます。\nmichimani/get-started-opensearch: Hello OpenSearch. Terraform で OpenSearch Service のドメインを定義する 下記ドキュメントを参考に、 OpenSearch Service のドメインを定義します。\naws_opensearch_domain | Resources | hashicorp/aws | Terraform Registry ドメイン 最小構成だとこんな感じになります。\nresource \u0026#34;aws_opensearch_domain\u0026#34; \u0026#34;first_opensearch\u0026#34; { domain_name = \u0026#34;first-opensearch\u0026#34; engine_version = \u0026#34;OpenSearch_1.2\u0026#34; cluster_config { instance_type = \u0026#34;t3.small.search\u0026#34; } ebs_options { ebs_enabled = true volume_size = 10 } } OpenSearch Service で指定できるエンジンは aws opensearch list-versions で確認できます。2022/07/04 現在だと下記のエンジンが指定可能です。\n{ \u0026#34;Versions\u0026#34;: [ \u0026#34;OpenSearch_1.2\u0026#34;, \u0026#34;OpenSearch_1.1\u0026#34;, \u0026#34;OpenSearch_1.0\u0026#34;, \u0026#34;Elasticsearch_7.10\u0026#34;, \u0026#34;Elasticsearch_7.9\u0026#34;, \u0026#34;Elasticsearch_7.8\u0026#34;, \u0026#34;Elasticsearch_7.7\u0026#34;, \u0026#34;Elasticsearch_7.4\u0026#34;, \u0026#34;Elasticsearch_7.1\u0026#34;, \u0026#34;Elasticsearch_6.8\u0026#34;, \u0026#34;Elasticsearch_6.7\u0026#34;, \u0026#34;Elasticsearch_6.5\u0026#34;, \u0026#34;Elasticsearch_6.4\u0026#34;, \u0026#34;Elasticsearch_6.3\u0026#34;, \u0026#34;Elasticsearch_6.2\u0026#34;, \u0026#34;Elasticsearch_6.0\u0026#34;, \u0026#34;Elasticsearch_5.6\u0026#34;, \u0026#34;Elasticsearch_5.5\u0026#34;, \u0026#34;Elasticsearch_5.3\u0026#34;, \u0026#34;Elasticsearch_5.1\u0026#34;, \u0026#34;Elasticsearch_2.3\u0026#34;, \u0026#34;Elasticsearch_1.5\u0026#34; ] } ドメインポリシー 今回は、構築する OpenSearch クラスターに対して Read (GET アクセス) のみ可能な IAM ロールと Write (POST, PUT, DELETE アクセス) も可能な IAM ロールを作成し、それらによるアクセス制御を行うためのドメインポリシーを設定します。 Terraform での定義は下記のようになります。\nresource \u0026#34;aws_opensearch_domain_policy\u0026#34; \u0026#34;first_domain_policy\u0026#34; { domain_name = aws_opensearch_domain.first_opensearch.domain_name access_policies = \u0026lt;\u0026lt;POLICIES { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;AccessByAdministrator\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: [ \u0026#34;arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/demo/opensearch-admin\u0026#34; ] }, \u0026#34;Action\u0026#34;: [ \u0026#34;es:*\u0026#34; ], \u0026#34;Condition\u0026#34;: { \u0026#34;IpAddress\u0026#34;: { \u0026#34;aws:SourceIp\u0026#34;: [ \u0026#34;${var.my_ip}\u0026#34; ] } }, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:es:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:domain/first-opensearch/*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AccessByReadOnlyUser\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: [ \u0026#34;arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/demo/opensearch-read-only\u0026#34; ] }, \u0026#34;Action\u0026#34;: [ \u0026#34;es:ESHttpGet\u0026#34; ], \u0026#34;Condition\u0026#34;: { \u0026#34;IpAddress\u0026#34;: { \u0026#34;aws:SourceIp\u0026#34;: [ \u0026#34;${var.my_ip}\u0026#34; ] } }, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:es:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:domain/first-opensearch/*\u0026#34; } ] } POLICIES } opensearch-admin というロールには es:* ですべてのアクションを許可し、 opensearch-read-only ロールには es:ESHttpGet で GET アクセスのみ許可します。また、今回は Condition で特定の IP からのアクセスのみ許可するようにしています。\nIAM ロールの方の定義はこちら。\nresource \u0026#34;aws_iam_role\u0026#34; \u0026#34;opensearch_ro_role\u0026#34; { name = \u0026#34;opensearch-read-only\u0026#34; path = \u0026#34;/demo/\u0026#34; assume_role_policy = \u0026lt;\u0026lt;POLICY { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;${var.iam_user_arn}\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } POLICY } resource \u0026#34;aws_iam_role\u0026#34; \u0026#34;opensearch_admin_role\u0026#34; { name = \u0026#34;opensearch-admin\u0026#34; path = \u0026#34;/demo/\u0026#34; assume_role_policy = \u0026lt;\u0026lt;POLICY { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;${var.iam_user_arn}\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } POLICY } 特定の IAM ユーザーからスイッチロールして使うことを想定しています。 ${var.iam_user_arn} には、実際にこれらのロールにスイッチする IAM ユーザーの ARN を variable で指定します。\nvariables.tf を作成して apply variables.tf は下記のような形で作成しておきます。\nvariable \u0026#34;my_ip\u0026#34; { default = \u0026#34;203.0.113.0\u0026#34; // Your machine\u0026#39;s global IP address. } variable \u0026#34;iam_user_arn\u0026#34; { default = \u0026#34;arn:aws:iam::000000000000:user/hoge\u0026#34; // ARN of the IAM User for which AWS CLI credentials have been set up. } 自身の IP アドレスの確認には、\ncurl -X GET \u0026#39;https://checkip.amazonaws.com/\u0026#39; がシンプルなのでおすすめです。\nあとは terraform apply でリソースを作成します。初回の apply には 15 分程度かかります。\nOpenSearch CLI でリクエストを投げる OpenSearch のクラスタが構築できたら、 OpenSearch CLI を使ってリクエストを投げてみます。\nOpenSearch CLI のインストール 下記ページからダウンロードします。\nOpensearch 2.0.1 · OpenSearch macOS の場合はインストーラ (pkg) 形式なので、ダウンロードしてインストーラの指示に従ってインストールします。\nプロファイルの設定 OpenSearch CLI はいくつかプロファイルを作成して使い分ける事ができます。 AWS CLI でいう --profile オプションみたいなのがあります。\nプロファイルの作成には OpenSearch クラスタの URL と、認証方法を指定する必要があります。\nまず、 OpenSearch クラスタの URL を取得します。\n今回は first-opensearch という名前でドメインを作成したので、下記の AWS CLI コマンドで URL (エンドポイント) を取得します。\nENDPOINT=$( aws opensearch describe-domain \\ --domain-name \u0026#39;first-opensearch\u0026#39; \\ --query \u0026#39;DomainStatus.join(``,[`https://`,Endpoint])\u0026#39; \\ --output text ) \u0026amp;\u0026amp; echo \u0026#34;${ENDPOINT}\u0026#34; 続いて認証方法についてですが、 OpenSearch CLI では下記の 3 の認証方法が指定できます。\ndisabled basic cert aws-iam 今回は、 IAM ロールでの認証を行うので aws-iam を認証方法として指定します。\nプロファイルの作成には下記コマンドを実行します。\nopensearch-cli profile create \\ --auth-type aws-iam \\ --endpoint \u0026#34;${ENDPOINT}\u0026#34; \\ --name env-role aws-iam を指定した場合、認証に使用する AWS のプロファイルと AWS のサービス名を聞かれます。\nプロファイルに関しては特定のプロファイルを指定する事もできますが、指定しない場合は実行環境の環境変数をもとに認証に使用するプロファイルが選択されます。今回は環境変数によって使用するプロファイルを使い分けることにします。\nAWS のサービス名は、 es または ec2 で指定します。今回は es を指定します。 (OpenSearch Service ですが es です)\nRead Only なロールでリクエストを投げてみる まずは Read Only なロール opensearch-read-only にスイッチしてリクエストを投げてみます。\nスイッチロールするには下記のコマンドを実行します。\nSWITCH_CMD=$( \\ aws sts assume-role \\ --role-arn $(aws iam list-roles \\ --path-prefix \u0026#39;/demo\u0026#39; \\ --query \u0026#39;Roles[?contains(to_string(RoleName), `opensearch-read-only`)].Arn\u0026#39; \\ --output text) \\ --role-session-name \u0026#39;opensearch-read-only\u0026#39; \\ --query \u0026#39;Credentials.join(``,[`export AWS_ACCESS_KEY_ID=\\\u0026#34;`,AccessKeyId,`\\\u0026#34; AWS_SECRET_ACCESS_KEY=\\\u0026#34;`,SecretAccessKey,`\\\u0026#34; AWS_SESSION_TOKEN=\\\u0026#34;`,SessionToken,`\\\u0026#34;`])\u0026#39; \\ --output text) \\ \u0026amp;\u0026amp; eval ${SWITCH_CMD} \\ \u0026amp;\u0026amp; aws sts get-caller-identity ちなみに、このコマンドを AWS CLI のエイリアスとしていい感じに設定しておくことで、 AWS CLI でのスイッチロールがめちゃくちゃ簡単になるよ というのを別記事で書いているので参考にしてみてください。\nAWS CLI のエイリアスを使ってメチャクチャ簡単にスイッチロールできるようにしてみた - michimani.net opensearch-read-only ロールにスイッチできたら、 GET のリクエストを投げてみます。\n$ opensearch-cli curl get \\ --path \u0026#39;_cluster/health\u0026#39; \\ --output-format yaml \\ --profile env-role --- cluster_name: \u0026#34;000000000000:first-opensearch\u0026#34; status: \u0026#34;green\u0026#34; timed_out: false number_of_nodes: 1 number_of_data_nodes: 1 discovered_master: true active_primary_shards: 1 active_shards: 1 relocating_shards: 0 initializing_shards: 0 unassigned_shards: 0 delayed_unassigned_shards: 0 number_of_pending_tasks: 0 number_of_in_flight_fetch: 0 task_max_waiting_in_queue_millis: 0 active_shards_percent_as_number: 100.0 続いて PUT リクエストを投げてみます。\n$ opensearch-cli curl put \\ --path \u0026#39;demoindex\u0026#39; \\ --profile env-role { \u0026#34;Message\u0026#34;: \u0026#34;User: arn:aws:sts::000000000000:assumed-role/opensearch-read-only/opensearch-read-only is not authorized to perform: es:ESHttpPut because no identity-based policy allows the es:ESHttpPut action\u0026#34; } こちらはエラーになりました。\nここまで終わったらスイッチロールを解除するために下記コマンドを実行します。\nunset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN Write も許可されてたロールでリクエストを投げてみる 次に Write も許可されたロール opensearch-admin にスイッチしてリクエストを投げてみます。\nopensearch-admin にスイッチするには下記コマンドを実行します。\nSWITCH_CMD=$( \\ aws sts assume-role \\ --role-arn $(aws iam list-roles \\ --path-prefix \u0026#39;/demo\u0026#39; \\ --query \u0026#39;Roles[?contains(to_string(RoleName), `opensearch-admin`)].Arn\u0026#39; \\ --output text) \\ --role-session-name \u0026#39;opensearch-admin\u0026#39; \\ --query \u0026#39;Credentials.join(``,[`export AWS_ACCESS_KEY_ID=\\\u0026#34;`,AccessKeyId,`\\\u0026#34; AWS_SECRET_ACCESS_KEY=\\\u0026#34;`,SecretAccessKey,`\\\u0026#34; AWS_SESSION_TOKEN=\\\u0026#34;`,SessionToken,`\\\u0026#34;`])\u0026#39; \\ --output text) \\ \u0026amp;\u0026amp; eval ${SWITCH_CMD} \\ \u0026amp;\u0026amp; aws sts get-caller-identity Read Only のときに失敗した PUT リクエストを投げてみます。\n$ opensearch-cli curl put \\ --path \u0026#39;demoindex\u0026#39; \\ --profile env-role {\u0026#34;acknowledged\u0026#34;:true,\u0026#34;shards_acknowledged\u0026#34;:true,\u0026#34;index\u0026#34;:\u0026#34;demoindex\u0026#34;} 今度は成功しました。続いて DELETE リクエストも投げてみます。\n$ opensearch-cli curl delete \\ --path \u0026#39;demoindex\u0026#39; \\ --profile env-role {\u0026#34;acknowledged\u0026#34;:true} こちらも成功しました。\nここまで終わったら、忘れずにスイッチロールを解除しておきます。\nunset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN まとめ Terraform で OpenSearch Service のドメイン、ドメインポリシーを定義した OpenSearch CLI で OpenSearch のクラスタにリクエストを投げてみた 副作用として AWS CLI でスイッチロールするワンライナーが生まれた ",
    "permalink": "https://michimani.net/post/aws-get-started-opensearch-service-via-terraform/",
    "title": "Terraform と OpenSearch CLI で OpenSearch Service に入門する"
  },
  {
    "contents": "AWS CLI でスイッチロールする場合、 sts assume-role で認証情報を取得し、それを環境変数なり ~/.aws/credentials に追記したりする必要があります。さくっとスイッチしたいだけなのに少々手間がかかるので、 AWS CLI のエイリアスを使ってコマンド一つでスイッチロールできるようにしてみました。\n結論 これです。\nawscli-aliases/alias at 9edd908f2d27c8a4acf07a6dc31ce7d19dc6ced3 · michimani/awscli-aliases AWS CLI でスイッチロールする流れ そもそものスイッチロールの仕組みと AWS CLI でスイッチロールする方法については下記の AWS Blog の記事に書かれています。\nIAM チュートリアル: AWS アカウント間の IAM ロールを使用したアクセスの委任 - AWS Identity and Access Management AWS CLI での流れを要約すると下記の通りとなります。\naws sts assume-role コマンドで、スイッチしたいロールの一時認証情報を取得する 取得した認証情報から、必要な値を下記の環境変数にそれぞれ設定する AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN たったこれだけですが、 2 の部分が多少手間がかかります。というのも、普通にやると sts assume-role の実行結果から必要な情報をコピペしてくる必要があるからです。\nこの手順 1, 2 を --query オプションを使っていい感じにしてみます。\nquery オプションを使ってワンライナーで書く まずは、手順 1 で実行するコマンドから。\n今回は、例として下記のような IAM ロールにスイッチしたいとします。 (iam get-role の出力の一部を抜粋)\n{ \u0026#34;Role\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/demo/\u0026#34;, \u0026#34;RoleName\u0026#34;: \u0026#34;target-role\u0026#34;, \u0026#34;RoleId\u0026#34;: \u0026#34;AROA2XXXXXXXXXXXXXXXX\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::00000000:role/demo/target-role\u0026#34;, } } 上記のロールにスイッチするためには下記コマンドを実行します。\naws sts assume-role \\ --role-arn \u0026#39;arn:aws:iam::00000000:role/demo/target-role\u0026#39; --role-session-name \u0026#39;switch-to-target-role\u0026#39; 正常に実行できれば、下記のような出力が得られます。\n{ \u0026#34;Credentials\u0026#34;: { \u0026#34;AccessKeyId\u0026#34;: \u0026#34;ASIAXXXXXXXXXXXXXXXX\u0026#34;, \u0026#34;SecretAccessKey\u0026#34;: \u0026#34;FbNIxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;SessionToken\u0026#34;: \u0026#34;IQxxxxx...............xxxxx+4w==\u0026#34;, \u0026#34;Expiration\u0026#34;: \u0026#34;2022-06-30T16:05:13+00:00\u0026#34; }, \u0026#34;AssumedRoleUser\u0026#34;: { \u0026#34;AssumedRoleId\u0026#34;: \u0026#34;AROA2XXXXXXXXXXXXXXXX:switch-to-target-role\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:sts::00000000:assumed-role/target-role/switch-to-target-role\u0026#34; } } この中から、 AccessKeyId 、 SecretAccessKey 、SessionToken をそれぞれ環境変数 AWS_ACCESS_KEY_ID 、 AWS_SECRET_ACCESS_KEY 、 AWS_SESSION_TOKEN に設定することでスイッチしたロールで AWS CLI のコマンドを実行することができます。\nLinux または macOS では環境変数の設定には export コマンドを使用するので、 --query オプションを使って環境変数設定用のコマンドを生成します。具体的には下記のように実行します。\naws sts assume-role \\ --role-arn \u0026#39;arn:aws:iam::00000000:role/demo/target-role\u0026#39; --role-session-name \u0026#39;switch-to-target-role\u0026#39; --query \u0026#39;Credentials.join(``,[`export AWS_ACCESS_KEY_ID=\\\u0026#34;`,AccessKeyId,`\\\u0026#34; AWS_SECRET_ACCESS_KEY=\\\u0026#34;`,SecretAccessKey,`\\\u0026#34; AWS_SESSION_TOKEN=\\\u0026#34;`,SessionToken,`\\\u0026#34;`])\u0026#39; \\ --output text 出力としては下記のようになります。\nexport AWS_ACCESS_KEY_ID=\u0026#34;FbNIxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; AWS_SECRET_ACCESS_KEY=\u0026#34;IQxxxxx...............xxxxx+4w==\u0026#34; AWS_SESSION_TOKEN=\u0026#34;IQxxxxx...............xxxxx+4w==\u0026#34; これをコピペして実行すればいいのですが、それもコマンドでやってしまいます。\nこの出力を一旦変数に入れ、それを eval で展開して実行します。\nSWITCH_CMD=$( \\ aws sts assume-role \\ --role-arn $( \\ aws iam get-role \\ --role-name \u0026#39;target-role\u0026#39; \\ --query \u0026#39;Role.Arn\u0026#39; \\ --output text) \\ --role-session-name \u0026#39;switch-to-target-role\u0026#39; \\ --query \u0026#39;Credentials.join(``,[`export AWS_ACCESS_KEY_ID=\\\u0026#34;`,AccessKeyId,`\\\u0026#34; AWS_SECRET_ACCESS_KEY=\\\u0026#34;`,SecretAccessKey,`\\\u0026#34; AWS_SESSION_TOKEN=\\\u0026#34;`,SessionToken,`\\\u0026#34;`])\u0026#39; \\ --output text) \\ \u0026amp;\u0026amp; eval ${SWITCH_CMD} \\ \u0026amp;\u0026amp; aws sts get-caller-identity eval で export コマンドを実行したあとは、正常にスイッチできているかを確認するために aws sts get-caller-identity を実行しています。\n実行結果としては下記のようになります。\n{ \u0026#34;UserId\u0026#34;: \u0026#34;AROA2XXXXXXXXXXXX:switch-to-target-role\u0026#34;, \u0026#34;Account\u0026#34;: \u0026#34;000000000000\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:sts::000000000000:assumed-role/target-role/switch-to-target-role\u0026#34; } 以上で、ワンライナーでスイッチロールできるようになりました。最後に、これを AWS CLI のエイリアスコマンドとして設定し、より簡単にスイッチロールできるようにしてみます。\nAWS CLI のエイリアスコマンドを設定する AWS CLI では、ユーザが任意のエイリアスコマンドを設定できるようになっています。\nAWS CLI エイリアスの作成と使用 - AWS Command Line Interface 例えば、下記のようなエイリアスを設定しておけば aws id と実行するだけでアカウント ID を確認することができます。\nid = sts get-caller-identity \\ --query \u0026#39;Account\u0026#39; \\ --output text エイリアスには引数で値を渡すこともできます。今回であれば可変なのはロール名のみなので、エイリアスの引数にロール名を渡すようにすればよいので、下記のようなエイリアスを設定することになります。\nswitch-role = !f() { SWITCH_CMD=$( \\ aws sts assume-role \\ --role-arn $( \\ aws iam get-role \\ --role-name \u0026#34;${1}\u0026#34; \\ --query \u0026#39;Role.Arn\u0026#39; \\ --output text) \\ --role-session-name \u0026#34;switch-to-${1}\u0026#34; \\ --query \u0026#39;Credentials.join(``,[`export AWS_ACCESS_KEY_ID=\\\u0026#34;`,AccessKeyId,`\\\u0026#34; AWS_SECRET_ACCESS_KEY=\\\u0026#34;`,SecretAccessKey,`\\\u0026#34; AWS_SESSION_TOKEN=\\\u0026#34;`,SessionToken,`\\\u0026#34;`])\u0026#39; \\ --output text) \\ \u0026amp;\u0026amp; eval ${SWITCH_CMD} \\ \u0026amp;\u0026amp; aws sts get-caller-identity }; f あとは aws switch-role 'target-role' と実行するだけでスイッチロールできます。\nさいごに AWS CLI のエイリアスいいぞ ワンライナー最高 どんどんスイッチしたくなる ちなみに、元のロールに戻りたい場合は下記コマンドを実行して各環境変数の値をクリアすれば OK です。\nunset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN ",
    "permalink": "https://michimani.net/post/aws-switch-role-via-aws-cli/",
    "title": "AWS CLI のエイリアスを使ってメチャクチャ簡単にスイッチロールできるようにしてみた"
  },
  {
    "contents": "Google Analytics のユニバーサルアナリティクス (UA) が 2023年 7月に廃止され、それ以降は Google Analytics 4 (GA4) を使う必要があります。まだ UA 廃止までの猶予はありますが、PV 等の各値を比較したくなったときに 1 年前のデータが無いと困るので、なるはやで移行しておく必要があります。今回は、とりあえずこのブログを UA から GA4 に移行してみます。\nユニバーサル アナリティクスのサポートは終了します - アナリティクス ヘルプ やること GA4 に切り替えていない状態で対象のプロパティの画面を開くと、ページ上部に下記のようなメッセージが表示されています。\nここの [開始] から GA4 のプロパティを設定していきます。\nプロパティの設定ができたら、発行されたスクリプトをブログの \u0026lt;head\u0026gt; タグ内に配置します。\n今回は、細かい設定はスキップして とりあえず GA4 のプロパティで PV だけでも計測できるようになることをゴールとします。\nGA4 プロパティの設定 先ほどの [開始] を押すと下記のような画面に遷移します。\n今回は新たに GA4 のプロパティを作成します。\n新しい Google アナリティクス 4 プロパティを作成する GA4 設定アシスタントの画面から 新しい Google アナリティクス 4 プロパティの作成 を開始すると、下記のようなウィザードが表示されます。\nここで [作成] を押すと、 GA4 設定アシスタントの画面に戻り、下記のような表示になる。\nGA4 のプロパティが作成された。\nGA4 プロパティの機能の確認と設定を行う [GA4 プロパティを確認] を押すと GA4 の設定画面に遷移します。\n正直、設定項目が多すぎてよくわからん。ので、欲を出さずに PV だけでも計測できるようになること を目指す。\nデータストリーム の項目を見ると、下記のようにまだデータが受信できていません。(それはそう)\nストリームの一覧から対象の行をクリックすると、下記のような詳細が表示されます。\nタグの設定手順 にある通り、データストリームで各値を計測するにはいずれかの方法でページ上にタグを埋め込む必要があります。\n今回は 新しいページ上のタグを追加する 、且つ GTM を使っていないため gtag.js を追加する方法で進めます。\n埋め込むタグは下記のような形式です。\n\u0026lt;!-- Global site tag (gtag.js) - Google Analytics --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXX\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;G-XXXXXXXXX\u0026#39;); \u0026lt;/script\u0026gt; これをこのブログの \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 内に配置します。\nGA4 のプロパティタグをブログに設置する このブログは Hugo で生成しており、テーマには Simplog を使っています。\nSimplog は UA のタグ埋め込みには対応しています (UA-XXXXXX を config.toml に追記するだけで OK) が、 GA4 の埋め込みには対応していません。ただ、 partials/additional-custom-head.html を作成すれば head 内にその内容が埋め込まれるようになっているので、 partials/additional-custom-head.html にプロパティタグを記述する方法で対応します。\nsimplog/head.html at c6940745f5b0751a408f3fc959f231b9ec624e5a · michimani/simplog ゆくゆくは G-XXXXXXXXX のタグを config.toml に記述するだけでタグが埋め込まれるようにしたい。(してくれる方がいたら PR お待ちしています)\n設置して様子を見る GA4 のプロパティタグを設置したらしばらく様子を見て、先ほどのデータストリームを確認します。\n他にやること GA4 の設定を見る限りだと\nGoogle Search Console との統合 Google AdSense との統合 あたりは設定が必要そうです。\n",
    "permalink": "https://michimani.net/post/development-migrate-google-analytics-gav4/",
    "title": "Hugo で生成しているブログをユニバーサルアナリティクスから Google Analytics 4 に移行する"
  }
]